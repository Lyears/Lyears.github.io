<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用 Mask-RCNN Benchmark 训练自定义数据集</title>
      <link href="/blog/2019/10/26/Python/17/"/>
      <url>/blog/2019/10/26/Python/17/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;Facebook AI Research 开源了 Faster R-CNN 和 Mask R-CNN 的 PyTorch 1.0 实现框架：MaskRCNN-Benchmark。他的性能相对更快，并且占用更少的 GPU 内存，它的亮点如下：</p><ul><li>PyTorch 1.0: 相当或者超越 Detectron 准确率的 RPN、Faster R-CNN 和 Mask R-CNN 的实现；</li><li>非常快: 训练速度是 Detectron 的两倍，是 mmdection 的 1.3 倍。</li><li>节省内存: 在训练过程中使用的 GPU 内存比 mmdetection 少大约 500MB；</li><li>使用多 GPU 训练和推理；</li><li>批量化推理:可以在每 GPU 每批量上使用多张图像进行推理；</li><li>支持 CPU inference: 可以在 CPU 上运行。</li><li>提供几乎所有参考 Mask R-CNN 和 Faster R-CNN 配置的预训练模型，具有 1x 的 schedule。</li></ul><p>&emsp;&emsp;这篇文章主要是记录我使用 Mask R-CNN benchmark 框架训练自定义数据集的过程，总的来说还是比较容易上手的，当然也有一些问题出现。下面便是使用的情况。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><em>我的开发环境如下:</em></p><ul><li>系统: Ubuntu 18.04LTS</li><li>Python 环境: miniconda3<ul><li>conda: 4.7.12 </li><li>Python: 3.7.4</li></ul></li><li>GCC: 7.3.0</li><li>CUDA: 10.0</li><li>pip: 19.3.1</li></ul><div class="note info">            <p><em>项目的要求如下:</em></p><ul><li>PyTorch 1.0 from a nightly release. It will not work with 1.0 nor 1.0.1. Installation instructions can be found in <a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">https://pytorch.org/get-started/locally/</a></li><li>torchvision from master</li><li>cocoapi</li><li>yacs</li><li>matplotlib</li><li>GCC &gt;= 4.9</li><li>OpenCV</li><li>CUDA &gt;= 9.0</li></ul>          </div><p><em>接下来跟着执行安装命令:</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># create the development environment</span></span><br><span class="line">conda create --name detection</span><br><span class="line"><span class="built_in">source</span> activate detection</span><br><span class="line"><span class="comment"># install the dependences</span></span><br><span class="line">conda install ninja yacs cython matplotlib tqdm opencv-python pycocotools</span><br><span class="line">conda install -c pytorch pytorch-nightly torchvision cudatoolkit=10.0</span><br></pre></td></tr></table></figure><hr /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># install the core projects</span></span><br><span class="line"><span class="built_in">export</span> INSTALL_DIR = <span class="variable">$PWD</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$INSTALL_DIR</span> </span><br><span class="line"><span class="comment"># install apex</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/NVIDIA/apex.git</span><br><span class="line"><span class="built_in">cd</span> apex</span><br><span class="line">python setup.py install --cuda_ext --cpp_ext</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$INSTALL_DIR</span></span><br><span class="line"><span class="comment"># install PyTorch Detection </span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/facebookresearch/maskrcnn-benchmark.git</span><br><span class="line"><span class="built_in">cd</span> maskrcnn-benchmark</span><br><span class="line">python setup.py build develop</span><br><span class="line"><span class="built_in">unset</span> INSTALL_DIR</span><br></pre></td></tr></table></figure><h1 id="准备数据集"><a href="#准备数据集" class="headerlink" title="准备数据集"></a>准备数据集</h1><p>&emsp;&emsp;安装完成后，下一步是要准备训练数据和验证数据。<br>&emsp;&emsp;maskrcnn-benchmark默认是使用COCO数据集的，因此需要把自己的数据集改成COCO的Detection格式。该数据集的标准是使用<em>JSON</em>文件存储，具体内容可以参考<a href="https://zhuanlan.zhihu.com/p/29393415" target="_blank" rel="noopener">COCO数据集的标注格式</a>一文。<br>&emsp;&emsp;COCO数据集的Detection部分主要的JSON结构体类型如下所示：<br><figure class="highlight json"><figcaption><span>annotations.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"root"</span>:&#123;</span><br><span class="line">        <span class="attr">"images"</span>: [</span><br><span class="line">            <span class="string">"0"</span>: &#123;</span><br><span class="line">                <span class="attr">"id"</span>: int, <span class="comment">//每张图片都有唯一的id标识</span></span><br><span class="line">                <span class="attr">"file_name"</span>: str, <span class="comment">//图片文件路径</span></span><br><span class="line">                <span class="attr">"width"</span>: int,</span><br><span class="line">                <span class="attr">"height"</span>: int</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"categories"</span>: [</span><br><span class="line">            <span class="string">"0"</span>: &#123;</span><br><span class="line">                <span class="attr">"id"</span>: int,</span><br><span class="line">                <span class="attr">"name"</span>: str,</span><br><span class="line">                <span class="attr">"count"</span>: int  <span class="comment">//每种category的数量</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="attr">"annotations"</span>: [</span><br><span class="line">            <span class="string">"0"</span>: &#123;</span><br><span class="line">                <span class="attr">"id"</span>: int, <span class="comment">//每个annotation都有唯一的id标识</span></span><br><span class="line">                <span class="attr">"image_id"</span>: int, <span class="comment">//对应于图片的id</span></span><br><span class="line">                <span class="attr">"segmentation"</span>: RLE or [polygon],  <span class="comment">//用多边形表示mask区域</span></span><br><span class="line">                <span class="attr">"category_id"</span>: int,  <span class="comment">//对应的category id</span></span><br><span class="line">                <span class="attr">"iscrowd"</span>: <span class="number">0</span> or <span class="number">1</span>,  <span class="comment">//表示是否是一组对象，如果为1，则segmentation用RLE格式，如果为0，则用polygons格式</span></span><br><span class="line">                <span class="attr">"area"</span>: float,  <span class="comment">//区域面积</span></span><br><span class="line">                <span class="attr">"bbox"</span>: [x,y,width,height]  <span class="comment">//通过这四个坐标定位bounding box</span></span><br><span class="line">            &#125;,</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;参考上面的格式分别生成训练集和验证集的json标注文件，随后将数据集文件链接到dataset文件夹目录下。目录格式可以参考下面:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── datasets</span><br><span class="line">│   └── coco #可以任意修改名称</span><br><span class="line">│       ├── annotations</span><br><span class="line">│  │  ├── instances_train2014.json #训练集标注文件</span><br><span class="line">│  │  └── instances_val2014.json #验证集标注文件</span><br><span class="line">│       ├── train2014  #存放训练集图片</span><br><span class="line">│       └── val2014  #存放验证集图片</span><br></pre></td></tr></table></figure></p><h1 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h1><p>&emsp;&emsp;在准备好数据文件之后，便可以通过修改配置文件来开始训练数据集，这里涉及的配置文件如下：</p><ul><li>模型参数配置文件：<code>configs/e2e_mask_rcnn_R_101_FPN_1x.yaml</code></li><li>数据集路径配置文件： <code>maskrcnn_benchmark/config/path_catalog.py</code></li></ul><p>&emsp;&emsp;需要修改的地方如下：<br><figure class="highlight python"><figcaption><span>path_catalog.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.</span></span><br><span class="line"><span class="string">"""Centralized catalog of paths."""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> copy <span class="keyword">import</span> deepcopy</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DatasetCatalog</span><span class="params">(object)</span>:</span></span><br><span class="line">    DATA_DIR = <span class="string">"datasets"</span></span><br><span class="line">    DATASETS = &#123;</span><br><span class="line">        <span class="string">"coco_2017_train"</span>: &#123;</span><br><span class="line">            <span class="string">"img_dir"</span>: <span class="string">"coco/train2017"</span>,</span><br><span class="line">            <span class="string">"ann_file"</span>: <span class="string">"coco/annotations/instances_train2017.json"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"coco_2017_val"</span>: &#123;</span><br><span class="line">            <span class="string">"img_dir"</span>: <span class="string">"coco/val2017"</span>,</span><br><span class="line">            <span class="string">"ann_file"</span>: <span class="string">"coco/annotations/instances_val2017.json"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>需要在<em>DETASETS</em>里面按照同样的格式输入image文件夹和annotation文件的位置。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生机试算法(二)</title>
      <link href="/blog/2019/02/26/Java/16/"/>
      <url>/blog/2019/02/26/Java/16/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本文接上一篇<a href="/2019/02/22/Java/15/">研究生机试算法</a>。在讨论完几个经典入门算法后，我们来开始系统地学习研究生机试算法。</p><a id="more"></a><h1 id="最大公约数"><a href="#最大公约数" class="headerlink" title="最大公约数"></a>最大公约数</h1><ul><li><p>当我们遇到诸如求最大公约数、最小公倍数之类的数学问题时，大多数人第一时间会想到暴力枚举求解，因为我们并没有系统地学习过这方面的数学知识。所以，当我们查阅资料，我们可以发现，使用欧几里得算法可以使算法更加高效。过程如下：</p><blockquote><p>若a,b全为零，则它们的最大公约数不存在；若a、b其中之一为零，则它们的最大公约数为a、b中非零的那个；若a、b都不为零，则使新a=b;新b=a%b，然后重复该过程。</p></blockquote></li><li><p>这就是我们要介绍的欧几里得算法，它改变了上文提到的枚举算法所需要的情况，将算法规模大大缩小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.algorithm.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCD</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextInt()) &#123;</span><br><span class="line">            a = sc.nextInt();</span><br><span class="line">            b = sc.nextInt();</span><br><span class="line">            System.out.println(gcd(a, b));</span><br><span class="line">            sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是求最大公约数的算法，同样也可以使用非递归形式。</p></li></ul><h1 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h1><ul><li>a、b的最小公倍数为<code>a*b/k</code>，k为a、b的最大公倍数，因此可以使用上述算法求解。</li></ul><h1 id="高精度整数"><a href="#高精度整数" class="headerlink" title="高精度整数"></a>高精度整数</h1><ul><li>如果计算的数据大于int(long)所能表示的最大范围，那么我们需要使用高精度整数类BigInteger，它里面内置了四则运算的API，只要考前查阅即可。</li></ul><h1 id="分解质因数"><a href="#分解质因数" class="headerlink" title="分解质因数"></a>分解质因数</h1><ul><li><p>顾名思义，对一个数<code>x</code> 分解质因数即确定素数$p_1p_2p_3$，使其满足<script type="math/tex">x = p_1^ {e_1} * p_2 ^ {e_2} * … * p_3 ^ {e_3}</script>，在特定条件下我们还要确定$e_1、e_2$等幂指数。</p></li><li><p>我们来看一道求质因数的个数的题（2007年清华大学研究生机试题），要求我们求出一个正整数N的质因数的个数，（1&lt;N&lt;10^9）。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.math;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumOfPrime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] mark = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">31623</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] prime = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">31623</span>];<span class="comment">//定义一个sqrt(10^9)大小的数组，保存质数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> primeSize = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        String str;</span><br><span class="line">        BufferedReader bf = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">        <span class="keyword">while</span> ((str = bf.readLine())!= <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(str);</span><br><span class="line">            out(n);</span><br><span class="line">        &#125;</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; primeSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (n % prime[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                    res++;<span class="comment">//每一个能整除的质数，都使结果+1</span></span><br><span class="line">                    n /= prime[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n != <span class="number">1</span>) res++;<span class="comment">//如果在范围内的质数都不能除尽该数，则证明在该范围内还存在一个质因数</span></span><br><span class="line"></span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化质数数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">31622</span>; i++) &#123;</span><br><span class="line">            mark[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">31622</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mark[i]) <span class="keyword">continue</span>;</span><br><span class="line">            prime[primeSize++] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt;= <span class="number">31622</span>; j += i) &#123;</span><br><span class="line">                mark[j] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="组合数"><a href="#组合数" class="headerlink" title="组合数"></a>组合数</h1><h2 id="关于n-的问题"><a href="#关于n-的问题" class="headerlink" title="关于n!的问题"></a>关于n!的问题</h2><ul><li><p>n!表示n的阶乘，并且有<code>n!=1 * 2 * 3 * … * n</code>成立，我们讨论一下关于它的问题，求n!中有多少个质因子p。如果我们先求n!在按上述计算，那么数据可能非常大，根本无法计算出来，因此我们需要更快的解。</p></li><li><p>我们以10!为例，显然其中有因子2的个数为5，$2^2$的个数为2，$2^3$的个数为1，因此共有8个质因子2。仔细思考变可以发现此过程可以推广为<em>n!</em>中有$(\frac{n}{p}+\frac{n}{p^2}+\frac{n}{p^3}+…)$个质因子p，其中除法均为向下取整。于是便得到了O(logn)算法，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        ans += n / p;</span><br><span class="line">        n /= p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用这个算法，可以很快计算出<em>n!</em>的末尾有多少个零，只要带入<code>cal(n, 5)</code>即可。</p></li></ul><h2 id="组合数的计算"><a href="#组合数的计算" class="headerlink" title="组合数的计算"></a>组合数的计算</h2><ul><li><p>组合数$C_n^m$是指从n个不同元素中选出m个元素的方案数（m≤n），其定义式为$C_n^m=\frac{n!}{m!(n-m)!}$，由三个整数的阶乘得到。通过定义可以知道，组合数满足$C_n^m=C_n^{n-m}$，且有$C_n^0=C_n^n=1$成立。本节讨论如下两个问题：</p><ol><li>如何计算$C_n^m$。</li><li>如何计算${C_n^m}$%p。</li></ol></li></ul><h3 id="第一个问题"><a href="#第一个问题" class="headerlink" title="第一个问题"></a>第一个问题</h3><h4 id="方法一：定义法"><a href="#方法一：定义法" class="headerlink" title="方法一：定义法"></a>方法一：定义法</h4><ul><li>通过定义式来算，先求阶乘，再除法，这样阶乘相当庞大，因此只能接受50以内的计算。</li></ul><h4 id="方法二：递推"><a href="#方法二：递推" class="headerlink" title="方法二：递推"></a>方法二：递推</h4><ul><li>我们可以得到组合数的递推公式：</li></ul><script type="math/tex; mode=display">\begin{equation}C_n^m = C_{n-1}^m + C_{n-1}^{m-1}\end{equation}​</script><p>&emsp;&emsp;从直观上看，公式总是把n减一，而把m保持原样或减一，这样这个递推公式最终总可以把n和m变成相同或是让m变为0，而又有$C_n^0=C_n^n=1$,这正好可以作为递归边界。代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span> || m == n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n - <span class="number">1</span>, m) + C(n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法三：定义式变形"><a href="#方法三：定义式变形" class="headerlink" title="方法三：定义式变形"></a>方法三：定义式变形</h4><ul><li>我们观察该式：</li></ul><script type="math/tex; mode=display">\begin{equation}\begin{aligned}C_n^m&=\frac{n!}{m!(n-m)!} \\&=\frac{(n-m+1)×(n-m+2)×…×(n-m+m)}{1×2×3×…×m}\\&=\frac{\frac{\frac{(n-m+1)×(n-m+2)}{2}×…}{…}×(n-m+m)}{m}\end{aligned}\end{equation}​</script><p>&emsp;&emsp;这样，就可以写出相应的代码了，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">C</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> n, <span class="keyword">long</span> <span class="keyword">long</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        ans = ans * (n - m + i) / i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h3><h4 id="方法一：递推取模"><a href="#方法一：递推取模" class="headerlink" title="方法一：递推取模"></a>方法一：递推取模</h4><ul><li>这种方法基于第一个问题的方法二，是最容易实现的一种。只要在原先的基础上适当的得房对p取模即可。</li></ul><h4 id="方法二：卢卡斯定理"><a href="#方法二：卢卡斯定理" class="headerlink" title="方法二：卢卡斯定理"></a>方法二：卢卡斯定理</h4><ul><li>如果p是素数，将m和n表示为p进制：</li></ul><script type="math/tex; mode=display">\begin{equation}\begin{aligned}m &= m_kp^k+m_{k-1}p^{k-1}+...+m_0\\n &= n_kp^k+n_{k-1}p^{k-1}+...+n_0\end{aligned}\end{equation}</script><p>&emsp;&emsp;那么卢卡斯定理告诉我们，<script type="math/tex">C_n^m=C_{n_k}^{m_k}×C_{n_{k-1}}^{m_{k-1}}×…×C_{n_0}^{m_0}(mod p)​</script>成立。例如对$C_8^3 mod 5​$来说，有</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}m&=3=0×5^1+3\\n&=8=1×5^1+3\end{aligned}\end{equation}</script><p>&emsp;&emsp;于是有$C_8^3mod5=C_1^0×C_3^3mod5=1​$。卢卡斯定理的证明不在此处，我们直接给出代码，并且为了看起来清晰，此处把<code>p</code>设为全局变量，不作为参数传来传去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Lucas</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> C(n % p, m % p) * Lucas(n / p, m / p) % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>研究生机试算法</title>
      <link href="/blog/2019/02/22/Java/15/"/>
      <url>/blog/2019/02/22/Java/15/</url>
      
        <content type="html"><![CDATA[<h1 id="补充一下"><a href="#补充一下" class="headerlink" title="补充一下"></a>补充一下</h1><ul><li>最近半年的时间我都在准备研究生考试，因此没有继续学习Java的主流框架。初试成绩出来后，按照以往的分数线我是可以参加复试的，所以这两个月在准备复试机试。考虑到可以使用eclipse （JAVA 6）的编译器，因此准备用Java来准备。虽然Java没有C/C++的速度，但是我更熟悉Java。<a id="more"></a></li></ul><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>复试上机环境是Java SE 6，因此将IDE的编译环境切换为Java SE 6。</li><li>根据《算法笔记》和《王道计算机考研机试指南》的顺序，按照经典入门题、数据结构相关、数学问题、图论问题、搜索算法和动态规划这几个模块来准备。</li></ul><h1 id="经典入门题"><a href="#经典入门题" class="headerlink" title="经典入门题"></a>经典入门题</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><ul><li><p>我们知道，最快捷的排序方法是快速排序，但是大部分人都没有直接记住排序的代码，因此在考场直接写快排是很麻烦的，因此我们可以借助Java库中的Arrays.Sort()函数来实现快速排序。我们只要定义好每个元素的比较方法即可。</p></li><li><p>我们以一道成绩排序题为例(清华大学2000年研究生机试题)，来看下如何调用类库中的Sort()进行快速操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GradeSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(sc.nextLine());</span><br><span class="line">        Student[] students = <span class="keyword">new</span> Student[n];</span><br><span class="line">        String[] str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            str = sc.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            students[i] = <span class="keyword">new</span> Student(Integer.parseInt(str[<span class="number">0</span>]), Integer.parseInt(str[<span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(students);</span><br><span class="line">        <span class="keyword">for</span> (Student s:</span><br><span class="line">             students) &#123;</span><br><span class="line">            System.out.println(s.id + <span class="string">" "</span> + s.grade);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">int</span> grade;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> grade)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.grade = grade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          定义排序的比较方案</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student o)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//成绩比较更优先</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.grade &lt; o.grade) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.grade &gt; o.grade) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">              <span class="comment">//如果相等，再比较学号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.id &lt; o.id) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>要注意的地方就是定义的compareTo()函数，返回-1表示被比较对象较小，反之较大。</p></li></ul><h2 id="日期类问题"><a href="#日期类问题" class="headerlink" title="日期类问题"></a>日期类问题</h2><ul><li><p>日期类问题也是在机试题中频繁出现的题目，我们要注意的仅仅是闰年的计算和2月天数的不同。以一道日期类问题为例（上海交大2009年机试题），来看下如何进行日期操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DayOfWeek</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] times = &#123;</span><br><span class="line">            <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] months = &#123;</span><br><span class="line">            <span class="string">"January"</span>, <span class="string">"February"</span>, <span class="string">"March"</span>, <span class="string">"April"</span>, <span class="string">"May"</span>, <span class="string">"June"</span>, <span class="string">"July"</span>, <span class="string">"August"</span>, <span class="string">"September"</span>, <span class="string">"October"</span>, <span class="string">"November"</span>, <span class="string">"December"</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String[] days = &#123;</span><br><span class="line">            <span class="string">"Sunday"</span>, <span class="string">"Monday"</span>, <span class="string">"Tuesday"</span>, <span class="string">"Wednesday"</span>, <span class="string">"Thursday"</span>, <span class="string">"Friday"</span>, <span class="string">"Saturday"</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; inList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        String in;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">            in = sc.nextLine();</span><br><span class="line">            <span class="keyword">if</span> (in.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            inList.add(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String res :</span><br><span class="line">                inList) &#123;</span><br><span class="line">            String[] strs = res.split(<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">int</span> day = Integer.parseInt(strs[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> month = Arrays.asList(months).indexOf(strs[<span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> year = Integer.parseInt(strs[<span class="number">2</span>]);</span><br><span class="line">            OwnDate date = <span class="keyword">new</span> OwnDate(year, month, day);</span><br><span class="line">            OwnDate flagDate = <span class="keyword">new</span> OwnDate(<span class="number">2019</span>, <span class="number">2</span>, <span class="number">24</span>);</span><br><span class="line">            <span class="keyword">int</span> diff;</span><br><span class="line">            <span class="comment">//根据两个日期的早晚，选定计数方式</span></span><br><span class="line">            <span class="keyword">boolean</span> fl = flag(date, flagDate);</span><br><span class="line">            <span class="keyword">if</span> (fl) &#123;</span><br><span class="line">                diff = (getValue(date, flagDate) - <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                diff = (getValue(flagDate, date) - <span class="number">1</span>) % <span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断往前计数还是往后计数</span></span><br><span class="line">            <span class="keyword">if</span> (fl) &#123;</span><br><span class="line">                System.out.println(days[<span class="number">7</span> - diff]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(days[diff]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OwnDate</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year;</span><br><span class="line">        <span class="keyword">int</span> month;</span><br><span class="line">        <span class="keyword">int</span> day;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OwnDate</span><span class="params">(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.year = year;</span><br><span class="line">            <span class="keyword">this</span>.month = month;</span><br><span class="line">            <span class="keyword">this</span>.day = day;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">OwnDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"OwnDate&#123;"</span> +</span><br><span class="line">                    <span class="string">"year="</span> + year +</span><br><span class="line">                    <span class="string">", month="</span> + month +</span><br><span class="line">                    <span class="string">", day="</span> + day +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为闰年</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isLeap</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">100</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">(OwnDate date1, OwnDate date2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> diff = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = date1.year; i &lt; date2.year; i++) &#123;</span><br><span class="line">            res += isLeap(i) ? <span class="number">366</span> : <span class="number">365</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (date1.month &lt; date2.month) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = date1.month - <span class="number">1</span>; j &lt; date2.month - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                diff += times[j];</span><br><span class="line">                <span class="keyword">if</span> (isLeap(i) &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res += diff;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (date1.month &gt; date2.month) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = date2.month - <span class="number">1</span>; j &lt; date1.month - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                diff += times[j];</span><br><span class="line">                <span class="keyword">if</span> (isLeap(i) &amp;&amp; j == <span class="number">1</span>) &#123;</span><br><span class="line">                    diff++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res -= diff;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res += (date2.day - date1.day);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较两个日期的大小</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果date1早于date2，则返回true</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">flag</span><span class="params">(OwnDate date1, OwnDate date2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (date1.year &lt; date2.year) &#123;</span><br><span class="line">            flag = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (date1.year == date2.year) &#123;</span><br><span class="line">            <span class="keyword">if</span> (date1.month &lt; date2.month) &#123;</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (date1.month == date2.month) &#123;</span><br><span class="line">                <span class="keyword">if</span> (date1.day &lt; date2.day) &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="Hash的应用"><a href="#Hash的应用" class="headerlink" title="Hash的应用"></a>Hash的应用</h2><ul><li><p>将数据的存储位置与数据本身对应起的手段就是Hash，我们所知的Hash算法、计数排序等都运用了这种思想。当我们遇到了统计学生人数的问题时，我们便可以使用Hash的思想。 以一道该类型的题目为例（2006年浙江大学机试真题）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StuGrade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        String[] gradeStrs;</span><br><span class="line">        String specGrade;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">            num = Integer.parseInt(sc.nextLine());</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            gradeStrs = sc.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">            specGrade = sc.nextLine();</span><br><span class="line">            out(num, gradeStrs, specGrade);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> n, String[] str, String spec)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//用HashMap来一一对应，少去不必要的操作</span></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s :</span><br><span class="line">                str) &#123;</span><br><span class="line">            map.put(s, map.get(s) == <span class="keyword">null</span> ? <span class="number">1</span> : map.get(s) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(map.get(spec) == <span class="keyword">null</span> ? <span class="number">0</span> : map.get(spec));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><ul><li>查找的重要性在整个算法体系中是不言而喻的，所以在机试中极有可能出现查找的题目，或者需要运用到。我们先来了解一下几个查找的基本要素。</li></ul><blockquote><p>1、查找空间。也常被称为解空间。所谓查找，就是在该查找空间中找寻符合我们要求的解的过程。</p><p>2、查找目标。我们需要一个目标来判断查找空间中的各个元素是否符合我们的要求，以便判断查找活动是否已经成功。</p><p>3、查找方法。即利用某种特定的策略在查找空间中查找各个元素。不同的策略对查找的效率和结果有不同的影响。</p></blockquote><ul><li><p>我们以一道普通的查找题为例（2003年清华大学研究生机试），来看下查找代码如何写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindStuInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line">        Map&lt;String, String&gt; inMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            String str = sc.nextLine();</span><br><span class="line">            <span class="comment">//由于每个学生的学号不同，因此可以使用Hash的方法来存储</span></span><br><span class="line">            inMap.put(str.split(<span class="string">" "</span>)[<span class="number">0</span>], str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = sc.nextInt();</span><br><span class="line">        sc.nextLine();</span><br><span class="line">        String[] nums = <span class="keyword">new</span> String[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            nums[i] = sc.nextLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String num :</span><br><span class="line">                nums) &#123;</span><br><span class="line">            System.out.println(inMap.get(num) == <span class="keyword">null</span> ? <span class="string">"No Answer!"</span> : inMap.get(num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在上一例中使用的是Hash方法，Java的HashMap中get()方法使用的是普通的遍历方法，这样的时间复杂度就非常的大了，这样可能导致程序不合格。为了满足条件，我们可以使用二分查找法，来加快查找速度，算法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">0</span>, top = <span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">while</span> (base &lt;= top)&#123; <span class="comment">//二分循环与二分查找一致</span></span><br><span class="line">    <span class="keyword">int</span> mid = (base + <span class="built_in">size</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &lt;= target) base = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> top = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = top;</span><br></pre></td></tr></table></figure></li></ul><h2 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h2><ul><li>这种算法思路较为简单，即一种总是选择“当前最好的选择”，而不从整体上去把握的思想，往往这种“贪心”的策略能够得到接近最优的结果，甚至最优的结果。我们以一道上机题为例（2012年浙江大学机试To fill or not to fill)，代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.algorithm.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.DecimalFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fzm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019-02-20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToFillOrNot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        DecimalFormat df = <span class="keyword">new</span> DecimalFormat(<span class="string">"#.00"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (sc.hasNextLine()) &#123;</span><br><span class="line">            <span class="comment">//最大油量</span></span><br><span class="line">            <span class="keyword">double</span> cMax = sc.nextDouble();</span><br><span class="line">            <span class="comment">//初始油量</span></span><br><span class="line">            <span class="keyword">double</span> capacity = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> maxDis = sc.nextInt();</span><br><span class="line">            <span class="comment">//平均油量路程</span></span><br><span class="line">            <span class="keyword">int</span> dAvg = sc.nextInt();</span><br><span class="line">            <span class="comment">//加油站数目</span></span><br><span class="line">            <span class="keyword">int</span> num = sc.nextInt();</span><br><span class="line">            <span class="keyword">double</span> onceMaxDis = cMax * dAvg;</span><br><span class="line">            <span class="keyword">int</span> dis = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">double</span> price = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//定义两个以距离或价格的加油站的排序数组</span></span><br><span class="line">            Station[] disStations = <span class="keyword">new</span> Station[num];</span><br><span class="line">            Station[] priceStations = <span class="keyword">new</span> Station[num];</span><br><span class="line">            Station here = <span class="keyword">null</span>;</span><br><span class="line">            sc.nextLine();</span><br><span class="line">            <span class="keyword">int</span> maxStationDis = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">                String[] str = sc.nextLine().split(<span class="string">" "</span>);</span><br><span class="line">                Station station = <span class="keyword">new</span> Station(Double.parseDouble(str[<span class="number">0</span>]), Integer.parseInt(str[<span class="number">1</span>]));</span><br><span class="line">                maxStationDis = Math.max(maxStationDis, Integer.parseInt(str[<span class="number">1</span>]));</span><br><span class="line">                disStations[i] = station;</span><br><span class="line">                priceStations[i] = station;</span><br><span class="line">                <span class="comment">//选定一个初始加油站</span></span><br><span class="line">                <span class="keyword">if</span> (station.distance == <span class="number">0</span>) &#123;</span><br><span class="line">                    here = station;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.sort(disStations, <span class="keyword">new</span> DisSort());</span><br><span class="line">            Arrays.sort(priceStations, <span class="keyword">new</span> PriceSort());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> success;</span><br><span class="line">            <span class="keyword">boolean</span> great;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//判断能否找到最优方案</span></span><br><span class="line">                great = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (Station s : disStations)</span><br><span class="line">                    <span class="keyword">if</span> (s != here &amp;&amp; dis &lt;= s.distance &amp;&amp; s.distance &lt;= dis + onceMaxDis) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s.price &lt;= here.price) &#123;</span><br><span class="line">                            <span class="comment">//计算油费</span></span><br><span class="line">                            <span class="keyword">if</span> ((s.distance - here.distance) / dAvg &gt; capacity) &#123;</span><br><span class="line">                                price += ((<span class="keyword">double</span>) (s.distance - here.distance) / dAvg - capacity) * here.price;</span><br><span class="line">                                capacity = <span class="number">0</span>;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                capacity -= (<span class="keyword">double</span>) (s.distance - here.distance);</span><br><span class="line">                            &#125;</span><br><span class="line">                            dis += (s.distance - here.distance);</span><br><span class="line">                            here = s;</span><br><span class="line">                            great = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!great) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Station s : priceStations) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (s != here &amp;&amp; dis &lt;= s.distance &amp;&amp; s.distance &lt;= dis + onceMaxDis) &#123;</span><br><span class="line">                            <span class="comment">//将油加满</span></span><br><span class="line">                            price += (cMax - capacity) * here.price;</span><br><span class="line">                            dis += (s.distance - here.distance);</span><br><span class="line">                            capacity = cMax - (<span class="keyword">double</span>) (s.distance - here.distance) / dAvg;</span><br><span class="line">                            here = s;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;  <span class="comment">//无法抵达</span></span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (here != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (here.distance == maxStationDis) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (maxDis &lt; maxStationDis + onceMaxDis) &#123;</span><br><span class="line">                            price += (<span class="keyword">double</span>) (maxDis - maxStationDis) / dAvg * here.price;</span><br><span class="line">                            success = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            dis += onceMaxDis;</span><br><span class="line">                            success = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                System.out.println(df.format(price));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"The maximum travel distance = "</span> + df.format(dis));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DisSort</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Station</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Station o1, Station o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o1.distance &lt; o2.distance) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o1.distance == o2.distance) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PriceSort</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Station</span>&gt; </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Station o1, Station o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Double.compare(o1.price, o2.price);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Station</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> price;</span><br><span class="line">        <span class="keyword">int</span> distance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Station</span><span class="params">(<span class="keyword">double</span> price, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">            <span class="keyword">this</span>.distance = distance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Station</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Station&#123;"</span> +</span><br><span class="line">                    <span class="string">"price="</span> + price +</span><br><span class="line">                    <span class="string">", distance="</span> + distance +</span><br><span class="line">                    <span class="string">'&#125;'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>本文介绍了排序、日期类问题、Hash、查找、贪心等在机试中频繁出现的基本算法。在完全了解后，相信能解决大部分简单的机试题了。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data 学习笔记（一）</title>
      <link href="/blog/2018/02/15/Java/14/"/>
      <url>/blog/2018/02/15/Java/14/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Spring Data : Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和关系数据存储。其主要目标是使数据库的访问变得方便快捷。</li><li>SpringData项目所支持NoSQL存储：<ul><li>MongoDB （文档数据库）</li><li>Neo4j（图形数据库）</li><li>Redis（键/值存储）</li><li>Hbase（列族数据库）</li></ul></li><li>SpringData项目所支持的关系数据存储技术：<ul><li>JDBC</li><li>JPA<a id="more"></a></li></ul></li></ul><h1 id="JPA-开发步骤"><a href="#JPA-开发步骤" class="headerlink" title="JPA 开发步骤"></a>JPA 开发步骤</h1><ul><li>使用 Spring Data JPA 进行持久层开发需要的四个步骤：<ul><li>配置 Spring 整合 JPA。</li><li>在 Spring 配置文件中配置 Spring Data，让 Spring 为声明的接口创建代理对象。配置了 <code>&lt;jpa:repositories&gt;</code> 后，Spring 初始化容器时将会扫描 base-package  指定的包目录及其子目录，为继承 Repository 或其子接口的接口创建代理对象，并将代理对象注册为 Spring Bean，业务层便可以通过 Spring 自动封装的特性来直接使用该对象。</li><li>声明持久层的接口，该接口继承  Repository，Repository 是一个标记型接口，它不包含任何方法，如必要，Spring Data 可实现 Repository 其他子接口，其中定义了一些常用的增删改查，以及分页相关的方法。</li><li>在接口中声明需要的方法。Spring Data 将根据给定的策略（具体策略稍后讲解）来为其生成实现代码。</li></ul></li></ul><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ul><li>加入相关maven依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-entitymanager --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.13.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.persistence/persistence-api --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.persistence<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>persistence-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-jpa --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>使用hibernate作为JPA的实现框架，因此需要加入hibernate-entitymanager的依赖，然后在配置文件中指定Vendor。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"entityManagerFactory"</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jpaVendorAdapter"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定hibernate为JPA提供框架--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"packagesToScan"</span> <span class="attr">value</span>=<span class="string">"com.javase.spring.data.jpa"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jpaProperties"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.ejb.naming_strategy"</span>&gt;</span>org.hibernate.cfg.ImprovedNamingStrategy<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQL5Dialect<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>同样还需配置好DataSource、TransactionManager来保证数据库的连接和事务的管理，最后配置jpa的repository接口需要扫描的包。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置jpa的repository接口需要扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">"com.javase.spring.data.jpa"</span> <span class="attr">entity-manager-factory-ref</span>=<span class="string">"entityManagerFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>相关的代码可以在我的<a href="https://github.com/dysmorsel/SpringDataLearingDemo" target="_blank" rel="noopener">GitHub</a>上查看。</li></ul><h2 id="编写实体类和接口"><a href="#编写实体类和接口" class="headerlink" title="编写实体类和接口"></a>编写实体类和接口</h2><ul><li>JPA基本注解：<ul><li>@Entity：标注用于实体类声明语句之前，<strong>指出该Java类为实体类，将映射到指定的数据库表</strong>。如声明一个实体类Customer，它将映射到数据库中的customer表上。</li><li>@Table：<strong>当实体类与其映射的数据库表名不同名</strong>时需要使用@Table标注说明，该标注与@Entity标注并列使用，置于实体类声明语句之前，可写于单独语句行，也可与声明语句同行。</li><li>@Id：@Id标注用于声明一个实体类的属性映射为数据库的<strong>主键列</strong>。该属性通常置于属性声明语句之前，可与声明语句同行，也可写在单独行上。</li><li>@GeneratedValue：<strong>用于标注主键的生成策略，通过 strategy属性指定</strong>。默认情况下，JPA自动选择一个最适合底层数据库的主键生成策略：SQL Server对应IDENTITY，MySQL对应AUTO INCREMENT。</li><li>@Column：<strong>当实体的属性与其映射的数据库表的列不同名时需要使用@Column标注说明</strong>，该属性通常置于实体的属性声明语句之前，还可与@Id标注一起使用。@Column标注的常用属性是name，用于设置映射数据库表的列名。此外，该标注还包含其它多个属性，如：<strong>unique 、nullable、length</strong> 等。</li><li>@Transient：表示该属性并非一个到数据库表的字段的映射，<strong>ORM框架将忽略该属性</strong>。如果一个属性并非数据库表的字段映射，就务必将其标示为@Transient。否则，ORM框架默认其注解为@Basic。</li><li>@Temporal：在核心的 JavaAPI 中并没有定义Date类型的精度(temporal precision)。而在数据库中，表示Date类型的数据有DATE，TIME， 和 TIMESTAMP三种精度(即单纯的日期，时间，或者两者兼备)。<strong>在进行属性映射时可使用@Temporal注解来调整精度。</strong></li></ul></li><li>基本注解示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"JPA_PERSONS"</span>)</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"LAST_NAME"</span>)</span><br><span class="line">    <span class="keyword">private</span> String lastName;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Temporal</span>(TemporalType.DATE)</span><br><span class="line">    <span class="keyword">private</span> Date birth;</span><br><span class="line">    <span class="comment">//省去Getter和Setter方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>映射关联关系</p><ul><li>关联关系分为单向关联和双向关联。单向关联需要在维护端添加@OneToMany注释或者@ManyToOne注释来表明维护关系。随后通过targetEntity属性指定关联实体类。之后使用@JoinColumn设置外键列名称。</li><li>双向关联关系分为一对多、一对一和多对多关系。双向一对多关系中，必须存在一个关系维护端，在JPA规范中，要求 many 的一方作为关系的维护端(ownerside)， one 的一方作为被维护端(inverseside)。建议在one方指定 @OneToMany 注释并设置<strong>mappedBy 属性</strong>，以指定它是这一关联中的被维护端，many 为维护端。</li><li>双向一对一及关系：基于外键的 1-1 关联关系：在双向的一对一关联中，需要在关系被维护端(inverseside)中的 @OneToOne注释中指定<strong>mappedBy</strong>，以指定是这一关联中的被维护端。同时需要在关系维护端(ownerside)建立外键列指向关系被维护端的主键列。</li><li>双向多对多关系：在双向多对多关系中，我们必须指定一个关系维护端(ownerside),可以通过@ManyToMany注释中指定<strong>mappedBy属性</strong>来标识其为关系被维护端。同时需要在关系维护端加入@JoinTable来指定关联表。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JoinTable</span>(name=<span class="string">"中间表名称"</span>,</span><br><span class="line">joinColumns=<span class="meta">@joinColumn</span>(name=<span class="string">"本类的外键"</span>,</span><br><span class="line">referencedColumnName=<span class="string">"本类与外键对应的主键"</span>),</span><br><span class="line">inversejoinColumns=<span class="meta">@JoinColumn</span>(name=<span class="string">"对方类的外键"</span>,</span><br><span class="line">referencedColunName=<span class="string">"对方类与外键对应的主键"</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>在上述示例中，为每个Person加一个商品类来加以对应，示例代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"JPA_INDENTS"</span>)</span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Indent</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"INDENT_NAME"</span>)</span><br><span class="line">    <span class="keyword">private</span> String indentName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JoinColumn</span>(name = <span class="string">"PERSON_ID"</span>)</span><br><span class="line">    <span class="comment">//@ManyToOne 表示多个商品对应一个人</span></span><br><span class="line">    <span class="meta">@ManyToOne</span>(targetEntity = Person<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Person</span> <span class="title">person</span></span>;</span><br><span class="line">    <span class="comment">//省去Getter和Setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>编写接口（Repository 接口概述）</p><ul><li>Repository 接口是SpringData 的一个核心接口，它不提供任何方法，开发者需要在自己定义的接口中声明需要的方法 <code>public interface Repository&lt;T, IDextends Serializable&gt; { }</code></li><li>Spring Data可以让我们只定义接口，只要<strong>遵循Spring Data的规范</strong>，就无需写实现类。 </li><li>基础的 Repository提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下： <ul><li>Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类</li><li>CrudRepository：继承Repository，实现了一组CRUD相关的方法 </li><li>PagingAndSortingRepository：继承CrudRepository，实现了一组分页排序相关的方法 </li><li>JpaRepository：继承PagingAndSortingRepository，实现了一组JPA规范相关的方法 </li><li>自定义的 XxxxRepository 建议继承 JpaRepository，这样的XxxxRepository接口就具备了<strong>通用的数据访问控制层的能力</strong>。</li><li>JpaSpecificationExecutor：不属于Repository体系，实现一组JPACriteria 查询相关的方法 </li></ul></li></ul></li><li><p>SpringData 方法定义规范</p><ul><li>简单条件查询：查询某一个实体类或者集合 按照Spring Data 的规范，查询方法以<strong>find | read | get</strong> 开头， 涉及条件查询时，条件的属性用条件关键字连接，要注意的是：<strong>条件属性以首字母大写</strong>。 例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Person</span>,<span class="title">Integer</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Person</span>&gt;,<span class="title">PersonDao</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据lastName找到相应的Person</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastName 实体类中的lastName属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的Person类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Person <span class="title">getByLastName</span><span class="params">(String lastName)</span></span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     *找出同时满足lastName以"XX"开头并且id小于"YY"时的所有Person</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastName 设定lastName需要以该字段开头</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 设定id需要小于该数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回对应的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">getByLastNameStartingWithAndIdLessThan</span><span class="params">(String lastName, Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件查询支持多种关键字，具体的内容请参考相关资料。</p><ul><li>使用@Query注解：@Query支持自定义查询，这种查询可以声明在 Repository方法中，<strong>摆脱像命名查询那样的约束，将查询直接在相应的接口方法中声明</strong>，结构更为清晰，这是Spring data 的特有实现。查询语句默认使用JPQL，如果要使用原生SQL，则需要在注解中的nativeQuery属性中定义为true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用自定义条件查询</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回id最大的Person</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Query</span>(<span class="string">"SELECT p FROM Person p WHERE p.id =(SELECT max (p2.id) FROM Person p2)"</span>)</span><br><span class="line">   <span class="function">Person <span class="title">getMaxPerson</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>可以在查询语句里面传入参数，在语句中使用<code>=:name</code>这种方式定义该参数名，然后使用@Param注解传入参数，注意保持参数名称一致。如果不使用@Param注解，那么当有多个参数时，请保持顺序一致。</p><ul><li>使用@Modifying注解：自定义查询还支持update和delete操作。一旦涉及到了数据库的修改时，需要为改方法添加@Modifying注解，同时为其添加@Transactional注解申明其为可修改事务。</li><li>注意事项：所有涉及到数据库修改操作时都需要<strong>添加@Transactional注解</strong>，如果自定义接口需要实现数据库的CRUD，那么需要为其<strong>实现</strong>一个Service，在Service的实现方法里面添加@Transactional注解。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonRepository personRepository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在saveAll()方法上添加@Transactional注解</span></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePersons</span><span class="params">(List&lt;Person&gt; people)</span></span>&#123;</span><br><span class="line">        personRepository.saveAll(people);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他接口的查询请查看测试代码的示例。</li><li>自定义Repository 方法：<ul><li>定义一个接口:声明要添加的,并自实现的方法</li><li>提供该接口的实现类: 类名需在要声明的Repository后添加Impl,并实现方法</li><li>声明 Repository接口,并继承已经声明的接口</li><li>使用</li><li>注意: 默认情况下,Spring Data 会在 base-package中查找”接口名Impl”作为实现类.也可以通过repository-impl-postfix声明后缀。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRepositoryImpl</span> <span class="keyword">implements</span> <span class="title">PersonDao</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PersistenceContext</span></span><br><span class="line">    <span class="keyword">private</span> EntityManager entityManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现自定义的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = entityManager.find(Person<span class="class">.<span class="keyword">class</span>,12)</span>;</span><br><span class="line">        System.out.println(<span class="string">"---&gt;"</span> + person.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringData </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Python中使用正则表达式</title>
      <link href="/blog/2017/11/07/Python/13/"/>
      <url>/blog/2017/11/07/Python/13/</url>
      
        <content type="html"><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>&emsp;&emsp;正则表达式，又称规则表达式，简称为regex，是文本模式的表示方法。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。</p><p>&emsp;&emsp;正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。<br><a id="more"></a> </p><ul><li>给定一个正则表达式和另一个字符串，我们可以达到如下的目的：</li></ul><ol><li>给定的字符串是否符合正则表达式的过滤逻辑（称作“匹配”）；</li><li>可以通过正则表达式，从字符串中获取我们想要的特定部分。</li></ol><ul><li>正则表达式的特点是：</li></ul><ol><li>灵活性、逻辑性和功能性非常强；</li><li>可以迅速地用极简单的方式达到字符串的复杂控制。</li><li>对于刚接触的人来说，比较晦涩难懂。</li></ol><h1 id="用正则表达式查找文本模式"><a href="#用正则表达式查找文本模式" class="headerlink" title="用正则表达式查找文本模式"></a>用正则表达式查找文本模式</h1><h2 id="创建正则表达式对象"><a href="#创建正则表达式对象" class="headerlink" title="创建正则表达式对象"></a>创建正则表达式对象</h2><p>&emsp;&emsp;Python中所有正则表达式的函数都在re模块中。在使用时，用<code>import</code>将其引入。向<code>re.compile</code>中传入一个字符串值，表示正则表达式，它将返回一个Regex模式对象。</p><p>&emsp;&emsp;要创建一个Regex对象，就要输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NumRegex = re.compile(<span class="string">r'\d\d\d'</span>)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在Python中，转义字符使用倒斜杠(<code>\</code>)。字符串’\n’表示一个换行字符，而不是倒斜杠加上一个小写的n。你需要输入转义字符<code>\\</code>，才能打印出一个倒斜杠。所以<code>&#39;\\n&#39;</code>表示一个倒斜杠加上一个小写的n。但是，通过在字符串的第一个引号之前加上r，可以将该字符串标记为原始字符串，它不包括转义字符。</p><p>&emsp;&emsp;因为正则表达式常常使用倒斜杠，向<code>re.compile()</code>函数传入原始字符串相对来说就比输入额外的倒斜杠方便，即输入<code>r&#39;\d\d\d&#39;</code>比输入<code>&#39;\\d\\d\\d&#39;</code>要容易得多。</p><h2 id="匹配Regex对象"><a href="#匹配Regex对象" class="headerlink" title="匹配Regex对象"></a>匹配Regex对象</h2><p>&emsp;&emsp;&emsp;&emsp;Regex对象的search()方法查找传入的字符串，寻找该正则表达式的所有匹配。如果字符串中没有找到该正则表达式，search()方法就会返回None。如果找到了该模式，search()方法将会返回一个Match对象。Match对象有一个group()方法，它返回被查找字符串中实际匹配的文本。下面是演示代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">phoneNumberRegex = re.compile(<span class="string">r'\d\d\d-\d\d\d-\d\d\d\d'</span>)</span><br><span class="line">mo = phoneNumberRegex.search(<span class="string">"My Number is 415-555-4242"</span>)</span><br><span class="line">print(<span class="string">'Phone number found: '</span> + mo.group())</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这样，将会打印匹配到的<code>415-555-4242</code>这个电话号码。</p><h1 id="用正则表达式匹配更多模式"><a href="#用正则表达式匹配更多模式" class="headerlink" title="用正则表达式匹配更多模式"></a>用正则表达式匹配更多模式</h1><h2 id="利用括号分组"><a href="#利用括号分组" class="headerlink" title="利用括号分组"></a>利用括号分组</h2><p>&emsp;&emsp;假定我想要上面那个电话号码的区号，即将区号从电话号码中分离，可以添加括号使正则表达式分组：<code>&#39;(\d\d\d)-(\d\d\d-\d\d\d\d)&#39;</code>。然后再使用group()方法匹配对象方法，从一个分组中获取匹配的文本。</p><p>&emsp;&emsp;正则表达式字符串中的第一对括号表示第一组。第二对括号表示第二组。向group()方法中传入整数1或2，就可以匹配文本的不同部分。向group()方法传入0或不传入参数，将返回整个匹配文本。下面是演示代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">phoneNumberRegex = re.compile(<span class="string">r'(\d\d\d)-(\d\d\d-\d\d\d\d)'</span>)</span><br><span class="line">mo = phoneNumberRegex.search(<span class="string">"My Number is 415-555-4242"</span>)</span><br><span class="line">print(mo.group(<span class="number">0</span>))</span><br><span class="line">print(mo.group(<span class="number">1</span>))</span><br><span class="line">print(mo.group(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>这样将依次返回<code>415-555-4242</code>、<code>415</code>、<code>555-4242</code>这三个结果。如果想一次就获得所有的分组，可以使用groups()这个方法，这样将会返回多个值得元组。</p><p>&emsp;&emsp;但是，括号在正则表达式中有特殊的含义，如果你要在文本中匹配括号的话，请在括号对前输入倒斜杠。即传递给re.compile()的原始字符串中，<code>\(</code>和<code>\)</code>转义字符将会匹配实际的括号字符。</p><h2 id="用管道匹配多个分组"><a href="#用管道匹配多个分组" class="headerlink" title="用管道匹配多个分组"></a>用管道匹配多个分组</h2><p>&emsp;&emsp;字符’|’称为管道。希望匹配许多表达式中的一个时，就可以使用它。例如正则表达式<code>r&#39;Batman|Tina&#39;</code>将匹配Batman或Tina。</p><p>&emsp;&emsp;也可以使用管道来匹配多个模式的一个，作为正则表达式的一部分。例如，假设你希望匹配<code>&#39;Batman&#39;</code>、<code>&#39;Batmobile&#39;</code>、<code>&#39;Batcopter&#39;</code>和<code>&#39;Batbar&#39;</code>中任意一个，由于所有的这些字符串都以Bat开始，所以如果能够只指定一次前缀，就很方便。可以通过括号实现。下面是演示代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">batRegex = re.compile(<span class="string">r'Bat(man|mobile|copter|bat)'</span>)</span><br><span class="line">mo2 = batRegex.search(<span class="string">'Batmobile lost a wheel'</span>)</span><br><span class="line">print(mo2.group(<span class="number">0</span>))</span><br><span class="line">print(mo2.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这样将会打印<code>Batmobile</code>和<code>mobile</code>。方法group()返回了完全匹配的文本’Batmobile’，而group(1)只是返回第一个括号分组内匹配的文本’mobile’。通过使用管道字符和分组括号，可以指定几种可选的模式，让正则表达式去匹配。</p><p>&emsp;&emsp;如果需要匹配真正的管道字符，就用倒斜杠转义，即<code>\|</code>。</p><h2 id="用问号实现可选匹配"><a href="#用问号实现可选匹配" class="headerlink" title="用问号实现可选匹配"></a>用问号实现可选匹配</h2><p>&emsp;&emsp;我们可以让匹配的模式是可选的。就是说，不论这段文本在不在，正则表达式都会认为匹配。字符？表明它前面的分组在这个模式是可选的。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">batRegex = re.compile(<span class="string">r'Bat(wo)?man'</span>)</span><br><span class="line">mo1 = batRegex.search(<span class="string">'The Adventures of Batman'</span>)</span><br><span class="line">print(mo1.group())</span><br><span class="line"></span><br><span class="line">mo2 = batRegex.search(<span class="string">'The Adventures of Batwoman'</span>)</span><br><span class="line">print(mo2.group())</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;正则表达式中的<code>(wo)?</code>部分表明，模式wo是可选的分组。该正则表达式匹配的文本中，wo将出现零次或多次。</p><h2 id="正则表达式用法总结"><a href="#正则表达式用法总结" class="headerlink" title="正则表达式用法总结"></a>正则表达式用法总结</h2><p>&emsp;&emsp;正则表达式还有许多表示法，就不一一全部演示了，这里给出常用的用法：</p><ul><li>？匹配零次或一次前面的分组。</li><li>*匹配零次或多次的分组。</li><li>+匹配一次或多次前面的分组。</li><li>{n}匹配n次前面的分组。</li><li>{n,}匹配n次或更多次前面的分组。</li><li>{,m}匹配零次到m次前面的分组。</li><li>{n,m}匹配至少n次、至多m次前面的分组。</li><li>{n,m}?或*？或+？对前面的分组进行非贪心匹配。</li><li>^begin意味着字符串必须以begin开头。</li><li>end$意味着字符串必须以end结尾。</li><li>.匹配所有字符，换行符除外。</li><li><code>\d</code>、<code>\w</code>和<code>\s</code>分别匹配数字、单词和空格。</li><li><code>\D</code>、<code>\W</code>和<code>\S</code>分别匹配除数字、单词和空格以外的所有字符。</li><li>[abc]匹配方括号在内的任意字符，诸如a、b或c。</li><li><sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>匹配不在方括号内的任意字符。</li></ul><h1 id="正则表达式应用"><a href="#正则表达式应用" class="headerlink" title="正则表达式应用"></a>正则表达式应用</h1><h2 id="利用正则表达式计算词频"><a href="#利用正则表达式计算词频" class="headerlink" title="利用正则表达式计算词频"></a>利用正则表达式计算词频</h2><p>&emsp;&emsp;我们可以利用正则表达式来操作数据，下面的代码是利用正则表达式给出网页中使用频率最高的十个词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_word_count</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> urllib.request.urlopen(url) <span class="keyword">as</span> doc:</span><br><span class="line">        word_count = &#123;&#125;</span><br><span class="line">        <span class="comment"># 得到这个页面的html文档</span></span><br><span class="line">        html = doc.read()</span><br><span class="line">        <span class="comment"># 匹配单词，不区分大小写</span></span><br><span class="line">        tex_regex = re.compile(<span class="string">r'[a-zA-Z]&#123;2,&#125;'</span>)</span><br><span class="line">        tex = tex_regex.findall(str(html))</span><br><span class="line">        <span class="keyword">for</span> word <span class="keyword">in</span> tex:</span><br><span class="line">            <span class="keyword">if</span> word <span class="keyword">in</span> word_count:</span><br><span class="line">                word_count[word] += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                word_count[word] = <span class="number">1</span></span><br><span class="line">        <span class="comment"># 对匹配到的结果进行排序，items()方法得到这个字典的元组列表，lambda的用法是lambda x:y,x是传入值，y是返回值。</span></span><br><span class="line">        <span class="comment"># key主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。item[1]就指定了根据字典中的值进行排序</span></span><br><span class="line">        <span class="comment"># reverse是指定排序方式为升序或降序，True为升序，默认为降序</span></span><br><span class="line">        list_sorted = sorted(word_count.items(), key=<span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">            <span class="comment"># 最后打印前十的单词和次数</span></span><br><span class="line">            print(list_sorted[i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_word_count(<span class="string">"http://www.baidu.com"</span>)</span><br></pre></td></tr></table></figure><p>最后得到结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'px'</span>, <span class="number">1954</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'background'</span>, <span class="number">428</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'icon'</span>, <span class="number">353</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'position'</span>, <span class="number">345</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'border'</span>, <span class="number">334</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'width'</span>, <span class="number">334</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'color'</span>, <span class="number">327</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'height'</span>, <span class="number">304</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'margin'</span>, <span class="number">231</span>)</span><br><span class="line"></span><br><span class="line">(<span class="string">'font'</span>, <span class="number">212</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring MVC 运行机制详解</title>
      <link href="/blog/2017/10/20/Java/14/"/>
      <url>/blog/2017/10/20/Java/14/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringMVC运行流程"><a href="#SpringMVC运行流程" class="headerlink" title="SpringMVC运行流程"></a>SpringMVC运行流程</h1><p>&emsp;&emsp;SpringMVC框架是Spring为展现层提供的基于MVC设计理念的优秀Web框架，是目前最主流的MVC框架之一。而它的强大之处就是通过一套MVC注解，让POJO成为处理请求的控制器，而无需实现任何的接口。<a id="more"></a><br>&emsp;&emsp;那么现在，我们开始探寻SpringMVC的运行机制。下面是SpringMVC的运行流程：<br><img data-src="http://dysmorsel.oss-cn-beijing.aliyuncs.com/blog/images/SpringMVC%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="MVC"></p><h1 id="配置SpringMVC"><a href="#配置SpringMVC" class="headerlink" title="配置SpringMVC"></a>配置SpringMVC</h1><p>&emsp;&emsp;SpringMVC框架围绕DispatcherServlet这个核心展开，它负责截取请求并将其分派给相应的处理器处理。SpringMVC框架包括注解驱动控制器、请求及响应的信息处理、视图解析、本地化解析、上传文件解析、异常处理及表单提交等内容。</p><h2 id="配置DispatcherServlet，截获特定的URL请求"><a href="#配置DispatcherServlet，截获特定的URL请求" class="headerlink" title="配置DispatcherServlet，截获特定的URL请求"></a>配置DispatcherServlet，截获特定的URL请求</h2><p>&emsp;&emsp;我们知道，在传统的JavaWeb项目中，我们可以在web.xml文件中配置一个servlet，然后通过<code>&lt;servlet-mapping&gt;</code>指定其处理的URL。假设我们希望SpringMVC的DispatcherServlet能够截获并处理所有以.html结束的URL请求，那么可以在web.xml中按如下方式进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ① --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ② --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>WEB-INF/springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ③ --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在①处通过contextConfigLocation参数指定业务层Spring容器的配置文件。然后调用ContextLoaderListener根据业务层Spring容器的配置文件启动业务层的Spring容器。<br>&emsp;&emsp;在②处配置了名为dispatcherServlet的DispatcherServlet，它默认自动加载/WEB-INF/dispatcherServlet-servlet.xml(<code>&lt;servlet-name&gt;-servlet.xml</code>)的Spring配置文件，这里显式地指定为WEB-INF目录下的springmvc.xml文件作为SpringMVC的配置文件。<br>&emsp;&emsp;在③处通过<code>&lt;servlet-mapping&gt;</code>指定dispatcherServlet处理所有HTTP请求。</p><h2 id="编写处理请求的控制器"><a href="#编写处理请求的控制器" class="headerlink" title="编写处理请求的控制器"></a>编写处理请求的控制器</h2><p>&emsp;&emsp;配置DispatcherServlet之后，开始编写处理请求的控制器。SpringMVC通过<code>@Controller</code>注解既可以将一个POJO转化为处理请求的控制器。通过<code>@RequestMapping</code>指定控制器需要处理的URL。下面是一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">helloWorld</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;首先使用<code>@Controller</code>对UserHandler类进行标注，使其成为一个可以处理HTTP请求的控制器。然后使用<code>@RequestMapping</code>对其中的helloWorld()方法进行标注，确定其处理的url为“hello”。helloWorld()方法返回了一个字符串“success”，它代表一个逻辑上的视图名，会被具体的视图解析器解析成一个具体的视图对象。稍后将讲解如何编写视图解析器和视图对象。</p><h2 id="编写视图解析器和视图对象"><a href="#编写视图解析器和视图对象" class="headerlink" title="编写视图解析器和视图对象"></a>编写视图解析器和视图对象</h2><h3 id="在配置文件中注册视图解析器："><a href="#在配置文件中注册视图解析器：" class="headerlink" title="在配置文件中注册视图解析器："></a>在配置文件中注册视图解析器：</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/views/"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个bean中，配置了视图对象的前缀和后缀，这样在返回的“success”字符串便会映射为/WEB-INF/views/success.jsp。这样，就会将这个jsp文件的视图内容进行渲染。</p><h3 id="编写视图对象"><a href="#编写视图对象" class="headerlink" title="编写视图对象"></a>编写视图对象</h3><p>&emsp;&emsp;在/WEB-INF目录下新建views文件夹，在里面新建success.jsp文件。本例中的控制器处理完后，将会转向到这个页面。代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>success<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>SUCCESS PAGE<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><br>这样我们就能在<code>host:port/WebRoot/hello</code>这个url下看到这个页面了。</p><h1 id="探究SpringMVC运行的内部机制"><a href="#探究SpringMVC运行的内部机制" class="headerlink" title="探究SpringMVC运行的内部机制"></a>探究SpringMVC运行的内部机制</h1><h2 id="DispatcherServlet的初始化"><a href="#DispatcherServlet的初始化" class="headerlink" title="DispatcherServlet的初始化"></a>DispatcherServlet的初始化</h2><p>&emsp;&emsp;在DispatcherServlet创建后，会按照它的一部分默认配置进行启动，这些默认配置可以在DispatcherServlet初始化过程中通过更改初始化参数进行修改。下面是一些常用的配置参数：</p><blockquote><p>namespace：DispatcherServlet对应的命名空间，默认为<code>&lt;servlet-name&gt;-servlet</code>，用于构造Spring配置文件的路径。</p><p>ContextConfigLocation：如果DispatcherServlet上下文对应的Spring配置文件有多个，则可以使用该属性按照Spring资源路径的方式指定。</p><p>publishContext：布尔类型的属性。默认为ture。DispatcherServlet根据该属性决定是否将WebApplicationContext发布到ServletContext的属性中，这样可以让使用者使用ServletContext找到WebAppliactionContext实例，对应的属性为可以通过getServletContextAttributeName()方法找到。</p><p>publishEvents：布尔类型的属性。当DispatcherServlet处理完一个请求后，是否需要向容器发布一个ServletRequestHandledEvents事件，默认为true。如果容器中没有任何事件监听器，则可以将该属性设置为false，以便提高性能。</p></blockquote><p>这些属性是如何获取的呢？我们知道servlet在初始化阶段会调用其init方法，所有我们首先要查看在DispatcherServlet中是否重写了init方法。我们在它的父类HTTPServletBean中找到了这个方法。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Initializing servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    <span class="comment">// 解析init-param并封装到pvs中</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将当前的这个servlet类转化为一个BeanWrapper，从而能够以Spring的方式来对初始化参数进行注册</span></span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            <span class="comment">//注册对于Resource类型的属性编辑器</span></span><br><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            <span class="comment">//注入属性</span></span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(<span class="string">"Servlet '"</span> + getServletName() + <span class="string">"' configured successfully"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>DispatcherServlet的初始化过程主要是通过将当前的servlet类型实例转化为BeanWrapper类型实例，以便使用Spring中提供的注入功能进行对属性的注入。这些属性就是servlet的配置参数。Spring会保证这些参数被注入到对应的值中。属性注入主要包含以下几个步骤：</p><h3 id="封装并验证初始化参数"><a href="#封装并验证初始化参数" class="headerlink" title="封装并验证初始化参数"></a>封装并验证初始化参数</h3><p>ServletConfigPropertyValues是一个在HttpServletBean的内部类，它除了封装属性外，还有对属性验证的功能，它的构造函数代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServletConfigPropertyValues</span><span class="params">(ServletConfig config, Set&lt;String&gt; requiredProperties)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果requiredProperties为空，missingProps就为空，否则新建一个HashSet储存missingProps。</span></span><br><span class="line">    Set&lt;String&gt; missingProps = (!CollectionUtils.isEmpty(requiredProperties) ? <span class="keyword">new</span> HashSet&lt;String&gt;(requiredProperties) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到初始化参数</span></span><br><span class="line">    Enumeration&lt;String&gt; paramNames = config.getInitParameterNames();</span><br><span class="line">    <span class="keyword">while</span> (paramNames.hasMoreElements()) &#123;</span><br><span class="line">        String property = paramNames.nextElement();</span><br><span class="line">        Object value = config.getInitParameter(property);</span><br><span class="line">        addPropertyValue(<span class="keyword">new</span> PropertyValue(property, value));</span><br><span class="line">        <span class="keyword">if</span> (missingProps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            missingProps.remove(property);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Fail if we are still missing properties.</span></span><br><span class="line">    <span class="comment">//如果missingProps为空，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(missingProps)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(</span><br><span class="line">            <span class="string">"Initialization from ServletConfig for servlet '"</span> + config.getServletName() +</span><br><span class="line">            <span class="string">"' failed; the following required properties were missing: "</span> +</span><br><span class="line">            StringUtils.collectionToDelimitedString(missingProps, <span class="string">", "</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从代码中可知，封装属性主要是对初始化的参数进行封装，也就是servlet中配置的<code>&lt;init-param&gt;</code>进行封装。当然，用户也可以通过对requiredProperties参数的初始化来强制验证某些属性的必要性，这样在属性封装的过程中，一旦检测到某些requiredProperties中的属性没有指定初始值，就会抛出异常。</p><h3 id="将当前servlet实例转化成BeanWrapper实例"><a href="#将当前servlet实例转化成BeanWrapper实例" class="headerlink" title="将当前servlet实例转化成BeanWrapper实例"></a>将当前servlet实例转化成BeanWrapper实例</h3><p>&emsp;&emsp;<code>PropertyAccessorFactory.forBeanPropertyAccess</code>是Spring中提供的工具方法，主要用于将指定实例转化为Spring中可以处理的BeanWrapper类型的实例。</p><h3 id="注册对于Resource类型的属性编辑器"><a href="#注册对于Resource类型的属性编辑器" class="headerlink" title="注册对于Resource类型的属性编辑器"></a>注册对于Resource类型的属性编辑器</h3><p>&emsp;&emsp;属性编辑器的原理是可以将非基本类型的属性进行处理，比如将Date属性转成字符串属性。在这里，属性编辑器一旦遇到Resource类型的属性将会使用ResourceEditor进行解析。</p><h3 id="注入属性"><a href="#注入属性" class="headerlink" title="注入属性"></a>注入属性</h3><p>&emsp;&emsp;<code>bw.setPropertyValues(pvs, true);</code>通过这行代码将属性注入。</p><h3 id="初始化servletBean"><a href="#初始化servletBean" class="headerlink" title="初始化servletBean"></a>初始化servletBean</h3><p>&emsp;&emsp;HttpServletBean的子类FrameworkServlet覆盖了它的initServletBean函数，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">"Initializing Spring FrameworkServlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization started"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        <span class="comment">//设计为子类的覆盖</span></span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (RuntimeException ex) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">        <span class="keyword">long</span> elapsedTime = System.currentTimeMillis() - startTime;</span><br><span class="line">        <span class="keyword">this</span>.logger.info(<span class="string">"FrameworkServlet '"</span> + getServletName() + <span class="string">"': initialization completed in "</span> +</span><br><span class="line">                elapsedTime + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的函数使用了计时器来统计初始化的执行时间，并且提供了一个扩展方法initFrameworkServlet()用于子类的覆盖操作。而作为关键的初始化逻辑实现则委托给了initWebApplicationContext()方法。</p><h2 id="WebApplicationContext的初始化"><a href="#WebApplicationContext的初始化" class="headerlink" title="WebApplicationContext的初始化"></a>WebApplicationContext的初始化</h2><p>&emsp;&emsp;initWebApplicationContext函数的主要工作就是创建或刷新WebApplicationContext实例并对servlet功能所使用的变量进行初始化。initWebApplicationContext函数在FarmeworkServlet中实现，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext =</span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 在构造时注入context文实例</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">// The context has not yet been refreshed -&gt; provide services such as</span></span><br><span class="line">                <span class="comment">// setting the parent context, setting the application context id, etc</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// The context instance was injected without an explicit parent -&gt; set</span></span><br><span class="line">                    <span class="comment">// the root application context (if any; may be null) as the parent</span></span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//刷新上下文环境</span></span><br><span class="line">                configureAndRefreshWebApplicationContext(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 根据contextAtrribute属性加载WebApplicationContext</span></span><br><span class="line">        wac = findWebApplicationContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No context instance is defined for this servlet -&gt; create a local one</span></span><br><span class="line">        wac = createWebApplicationContext(rootContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">        <span class="comment">// Either the context is not a ConfigurableApplicationContext with refresh</span></span><br><span class="line">        <span class="comment">// support or the context injected at construction time had already been</span></span><br><span class="line">        <span class="comment">// refreshed -&gt; trigger initial onRefresh manually here.</span></span><br><span class="line">        onRefresh(wac);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">        <span class="comment">// Publish the context as a servlet context attribute.</span></span><br><span class="line">        String attrName = getServletContextAttributeName();</span><br><span class="line">        getServletContext().setAttribute(attrName, wac);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"Published WebApplicationContext of servlet '"</span> + getServletName() +</span><br><span class="line">                    <span class="string">"' as ServletContext attribute with name ["</span> + attrName + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于该函数中的初始化方法，主要包含以下几个部分。</p><h3 id="寻找或创建对应的WebApplicationContext实例"><a href="#寻找或创建对应的WebApplicationContext实例" class="headerlink" title="寻找或创建对应的WebApplicationContext实例"></a>寻找或创建对应的WebApplicationContext实例</h3><p>&emsp;&emsp;WebApplicationContext的寻找及创建包括以下几个步骤。</p><ul><li>通过构造函数的注入进行初始化</li></ul><p>&emsp;&emsp;当进入initWebApplicationContext函数后通过判断<code>this.webApplicationContext!=null</code>后，便可以确定<code>this.webApplicationContext</code>是否是通过构造函数来初始化的。</p><ul><li>通过contextAttribute进行初始化</li></ul><p>&emsp;&emsp;通过在web.xml文件中配置的servlet参数contextAttribute来查找ServletContext中对应的属性，默认为WebApplicationContext.class.getName()+”.ROOT”，也就是在ContextLoaderListener加载时会创建WebApplicationContext实例，并将实例以WebApplicationContext.class.getName()+”.ROOT”为key放入ServletContext中，当然也可以重写初始化逻辑使用自己创建的WebApplicationContext，并在servlet的配置中通过初始化参数contextAttribute指定key。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">findWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String attrName = getContextAttribute();</span><br><span class="line">    <span class="keyword">if</span> (attrName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    WebApplicationContext wac =</span><br><span class="line">            WebApplicationContextUtils.getWebApplicationContext(getServletContext(), attrName);</span><br><span class="line">    <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No WebApplicationContext found: initializer not registered?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>重新创建WebApplicationContext实例</li></ul><p>&emsp;&emsp;如果通过以上两种方法都没有成功，那么就只能重新创建新的实例了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(WebApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createWebApplicationContext((ApplicationContext) parent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">createWebApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取servlet初始化参数contextClass，如果没有就默为XmlWebApplicationContext.class</span></span><br><span class="line">    Class&lt;?&gt; contextClass = getContextClass();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.logger.debug(<span class="string">"Servlet with name '"</span> + getServletName() +</span><br><span class="line">                <span class="string">"' will try to create custom WebApplicationContext context of class '"</span> +</span><br><span class="line">                contextClass.getName() + <span class="string">"'"</span> + <span class="string">", using parent context ["</span> + parent + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!ConfigurableWebApplicationContext<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">contextClass</span>)) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(</span><br><span class="line">                <span class="string">"Fatal initialization error in servlet with name '"</span> + getServletName() +</span><br><span class="line">                <span class="string">"': custom WebApplicationContext class ["</span> + contextClass.getName() +</span><br><span class="line">                <span class="string">"] is not of type ConfigurableWebApplicationContext"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过反射方法实例化contextClass</span></span><br><span class="line">    ConfigurableWebApplicationContext wac =</span><br><span class="line">            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);</span><br><span class="line"></span><br><span class="line">    wac.setEnvironment(getEnvironment());</span><br><span class="line">    <span class="comment">//parent为在ContextLoaderListener中创建的实例</span></span><br><span class="line">    wac.setParent(parent);</span><br><span class="line">    <span class="comment">//获取contextConfigLocation属性，配置在servlet初始化参数中</span></span><br><span class="line">    wac.setConfigLocation(getContextConfigLocation());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化Spring环境包括加载配置文件等</span></span><br><span class="line">    configureAndRefreshWebApplicationContext(wac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="调用configureAndRefreshWebApplicationContext方法"><a href="#调用configureAndRefreshWebApplicationContext方法" class="headerlink" title="调用configureAndRefreshWebApplicationContext方法"></a>调用configureAndRefreshWebApplicationContext方法</h3><p>&emsp;&emsp;无论是通过构造函数注入还是单独创建，都免不了会调用configureAndRefreshWebApplicationContext方法来对已经创建的WebApplicationContext实例进行配置及刷新，这个步骤的具体实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                    ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(getServletContext());</span><br><span class="line">    wac.setServletConfig(getServletConfig());</span><br><span class="line">    wac.setNamespace(getNamespace());</span><br><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line">    <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">    <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postProcessWebApplicationContext(wac);</span><br><span class="line">    applyInitializers(wac);</span><br><span class="line">    wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>无论调用方式是什么，只要是使用了ApplicationContext所提供的功能，最后都会使用其共同父类AbstractApplicationContext提供的<code>refresh()</code>进行配置文件的加载。</p><h3 id="刷新"><a href="#刷新" class="headerlink" title="刷新"></a>刷新</h3><p>&emsp;&emsp;onRefresh是FrameworkServlet类中提供的模板方法，在其子类DispatcherServlet中进行了重写，主要用于<strong>刷新Spring在Web功能实现中所必须使用的全局变量</strong>。下面是初始化过程代码，其具体的使用细节会在后面的文章内介绍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initialize the strategy objects that this servlet uses.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 中的优化配置</title>
      <link href="/blog/2017/10/10/Java/11/"/>
      <url>/blog/2017/10/10/Java/11/</url>
      
        <content type="html"><![CDATA[<h1 id="将配置信息放置在properties文件中"><a href="#将配置信息放置在properties文件中" class="headerlink" title="将配置信息放置在properties文件中"></a>将配置信息放置在properties文件中</h1><p>&emsp;&emsp;在之前说明如何初步配置MyBatis文件时我们都是将数据库配置信息写在xml文件下或者是代码块中，这样做有一定的安全隐患。因此我们可以将配置信息单独地放置在properties文件中，然后在config.xml文件下引入properties文件，具体做法如下：</p><ul><li>在resources目录下新建config.properties文件。</li><li>在config.properties文件中写入数据库的基本配置信息。<a id="more"></a></li><li>在config.xml文件中引入配置信息：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"config.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--resource指向mapper映射器配置文件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"userMapping.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.mapping.UserMapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h1><h2 id="简化映射语句的引用"><a href="#简化映射语句的引用" class="headerlink" title="简化映射语句的引用"></a>简化映射语句的引用</h2><p>&emsp;&emsp;之前我们在映射文件中引用实体类时，需要写入实体类的全名，即包名+类名。这样如果有比较多的语句的话相对来说会很麻烦。比如这个语句：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.domain.User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里resultType=<strong>“com.domain.User”</strong>写的是实体类的全名，每次都写这么长的话，会比较麻烦，为此我们希望能够简写成如下样式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 查询语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line">    SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>即不写实体类的包名。这样的话就为<strong>com.domain.User</strong>类定义一个别名为<strong>User</strong>，简化开发。要达到这种效果的话只要在config.xml文件的<code>&lt;configuration&gt;&lt;/configuration&gt;</code>标签下添加如下配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.domain"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样做的目的是将整个com.domain包下的实体类定义了默认别名，让它们在引用的时候不需要写包名。但如果我们需要为某个实体类单独配置的话，需要这么写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"com.domain.User"</span> <span class="attr">alias</span>=<span class="string">"_user"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就为com.domain.User类单独配置了一个别名_user。</p><h2 id="解决实体类名与数据表字段名不一致的冲突"><a href="#解决实体类名与数据表字段名不一致的冲突" class="headerlink" title="解决实体类名与数据表字段名不一致的冲突"></a>解决实体类名与数据表字段名不一致的冲突</h2><p>&emsp;&emsp;很多情况下我们表中的字段名与我们定义的实体类名不一致，这样我们在使用映射语句的时候就会出现诸如无法查询到数据等错误。因此，我们首先创建一个新的数据表以供测试：</p><h3 id="新建测试数据表"><a href="#新建测试数据表" class="headerlink" title="新建测试数据表"></a>新建测试数据表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_user(</span><br><span class="line">    user_id <span class="built_in">INT</span>(<span class="number">10</span>) PRIMARY <span class="keyword">key</span>,</span><br><span class="line">    user_name <span class="built_in">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    user_age <span class="built_in">INT</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_user(user_id,user_name,user_age) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">"Tom"</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> test_user(user_id,user_name,user_age) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="string">"Mike"</span>,<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>实体类与上文一致。</p><h3 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h3><p>&emsp;&emsp;创建一个testMapper.xml文件，内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"domain.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--不进行任何修改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"_user"</span>&gt;</span></span><br><span class="line">        SELECT * FROM test_user WHERE user_id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>发现无法查询到任何内容，因为我们实体类的名字与字段名不一致。修改SQL语句，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"domain.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--手动对应实体类与数据表--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"_user"</span>&gt;</span></span><br><span class="line">        SELECT user_id id,user_name name,user_age age FROM test_user WHERE user_id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样可以查询到结果，因为我们手动将实体类的名字与字段名对应起来了。但是这样做在写多条SQL时依旧很麻烦，因此我们可以为结果添加别名。代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"domain.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"_user"</span> <span class="attr">resultMap</span>=<span class="string">"resultMap"</span>&gt;</span></span><br><span class="line">        SELECT * FROM test_user WHERE user_id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"resultMap"</span> <span class="attr">type</span>=<span class="string">"com.domain.User"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用id属性来映射主键字段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"user_id"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用result属性来映射非主键字段 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"name"</span> <span class="attr">column</span>=<span class="string">"user_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"age"</span> <span class="attr">column</span>=<span class="string">"user_age"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就能查询到我们想要的结果了。如果是使用接口语句呢，可以使用相同的操作。首先创建接口文件，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mapping;</span><br><span class="line"><span class="keyword">import</span> com.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestUserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//不进行任何修改</span></span><br><span class="line">    <span class="meta">@Select</span>(value = <span class="string">"SELECT * FROM test_user WHERE user_id = #&#123;id&#125; "</span>)</span><br><span class="line">    <span class="function">User <span class="title">selectUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样无法查询到任何结果，在SQL语句中为结果添加别名，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestUserMapper</span> </span>&#123;</span><br><span class="line">    <span class="comment">//手动对应实体类与数据表</span></span><br><span class="line">    <span class="meta">@Select</span>(value = <span class="string">"SELECT user_id id,user_name name,user_age age FROM test_user WHERE user_id = #&#123;id&#125; "</span>)</span><br><span class="line">    <span class="function">User <span class="title">selectUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样也可以查询到结果，因为我们手动将实体类的名字与字段名对应起来了。同样可以使用<code>@Result</code>修饰返回的结果集，关联实体类属性和数据库字段一一对应,如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mapping;</span><br><span class="line"><span class="keyword">import</span> com.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Result;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Results;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TestUserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(value = <span class="string">"SELECT * FROM test_user WHERE user_id = #&#123;id&#125; "</span>)</span><br><span class="line">    <span class="meta">@Results</span>(&#123;</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"id"</span>,column = <span class="string">"user_id"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"name"</span>,column = <span class="string">"user_name"</span>),</span><br><span class="line">            <span class="meta">@Result</span>(property = <span class="string">"age"</span>,column = <span class="string">"user_age"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function">User <span class="title">selectUser</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用添加注解的方式为结果集添加别名，这样也能查询到我们想要的结果。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;使用优化配置后，对我们提升开发速度是有一定帮助的，但这些配置并没有全部介绍完，感兴趣的可以去阅读<a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">官方介绍</a>。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用MyBatis进行CURD操作</title>
      <link href="/blog/2017/09/28/Java/10/"/>
      <url>/blog/2017/09/28/Java/10/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>&emsp;&emsp;在上一篇文章<a href="/2017/09/17/Java/7">MyBatis 配置详解</a>中已经详细地介绍了MyBatis的配置环境，算是对MyBatis有了初步的理解了。今天讲下如何使用MyBatis对数据表进行进行增删改查，本文使用的测试环境是上一篇文章中的测试环境。<br><a id="more"></a></p><h1 id="基于XML文件的实现"><a href="#基于XML文件的实现" class="headerlink" title="基于XML文件的实现"></a>基于XML文件的实现</h1><h2 id="在mapper-xml文件中写入操作语句，代码如下："><a href="#在mapper-xml文件中写入操作语句，代码如下：" class="headerlink" title="在mapper.xml文件中写入操作语句，代码如下："></a>在mapper.xml文件中写入操作语句，代码如下：</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"domain.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--parameterType为传入的数据类型，resultType为结果数据类型，resultType="com.domain.User"表示将结果封装成一个User类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"com.domain.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.domain.User"</span> &gt;</span></span><br><span class="line">        INSERT INTO user(id,name,age) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        DELETE FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span> <span class="attr">parameterType</span>=<span class="string">"com.domain.User"</span>&gt;</span></span><br><span class="line">        UPDATE user SET name=#&#123;name&#125; ,age=#&#123;age&#125; WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAllUsers"</span> <span class="attr">resultType</span>=<span class="string">"com.domain.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="测试代码如下："><a href="#测试代码如下：" class="headerlink" title="测试代码如下："></a>测试代码如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.BeforeSuite;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCURD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeSuite</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> SqlSession <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String resource = <span class="string">"config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"dysmorsel"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setId(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据mapper.xml内的命名空间和方法id找到相应的方法，传入参数</span></span><br><span class="line">            <span class="keyword">int</span> result = session.insert(<span class="string">"domain.userMapper.insertUser"</span>,user);</span><br><span class="line">            <span class="comment">//手动提交</span></span><br><span class="line">            session.commit();</span><br><span class="line">            <span class="comment">//打印结果参数，0为失败，1为成功</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//操作结束，关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = session.delete(<span class="string">"domain.userMapper.deleteUser"</span>,<span class="number">3</span>);</span><br><span class="line">            session.commit();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            User user = session.selectOne(<span class="string">"domain.userMapper.selectUser"</span>,<span class="number">3</span>);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"dysmorsel"</span>);</span><br><span class="line">        user.setAge(<span class="number">22</span>);</span><br><span class="line">        user.setId(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> result = session.insert(<span class="string">"domain.userMapper.updateUser"</span>,user);</span><br><span class="line">            session.commit();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//操作结束，关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line">        <span class="comment">//执行查询操作，将查询结果自动封装成List&lt;User&gt;返回</span></span><br><span class="line">        List&lt;User&gt; users = session.selectList(<span class="string">"domain.userMapper.getAllUsers"</span>);</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基于接口方法的实现"><a href="#基于接口方法的实现" class="headerlink" title="基于接口方法的实现"></a>基于接口方法的实现</h1><h2 id="在UserMapperj接口中写入操作语句，代码如下："><a href="#在UserMapperj接口中写入操作语句，代码如下：" class="headerlink" title="在UserMapperj接口中写入操作语句，代码如下："></a>在UserMapperj接口中写入操作语句，代码如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Delete;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Insert;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Update;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义sql映射的接口，使用注解指明方法要执行的SQL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(value = <span class="string">"SELECT * FROM user WHERE id = #&#123;id&#125; "</span>)</span><br><span class="line">     <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert</span>(<span class="string">" INSERT INTO user(id,name,age) VALUES (#&#123;id&#125;,#&#123;name&#125;,#&#123;age&#125;)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete</span>(<span class="string">"delete from user where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update</span>(<span class="string">"update user set name=#&#123;name&#125;,age=#&#123;age&#125; where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from user"</span>)</span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试代码如下：-1"><a href="#测试代码如下：-1" class="headerlink" title="测试代码如下："></a>测试代码如下：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.domain.User;</span><br><span class="line"><span class="keyword">import</span> com.mapping.UserMapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.io.Resources;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.BeforeSuite;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCURD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeSuite</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> SqlSession <span class="title">before</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String resource = <span class="string">"config.xml"</span>;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"dysmorsel"</span>);</span><br><span class="line">        user.setAge(<span class="number">18</span>);</span><br><span class="line">        user.setId(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserMapper mapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">//根据mapper.xml内的命名空间和方法id找到相应的方法，传入参数</span></span><br><span class="line">            <span class="keyword">int</span> result = mapper.insertUser(user);</span><br><span class="line">            session.commit();</span><br><span class="line">            <span class="comment">//打印结果参数，0为失败，1为成功</span></span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//操作结束，关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserMapper mapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">int</span> result = mapper.deleteById(<span class="number">3</span>);</span><br><span class="line">            session.commit();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSelect</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            UserMapper mapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            User user = mapper.selectUser(<span class="number">3</span>);</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setName(<span class="string">"dysmorsel"</span>);</span><br><span class="line">        user.setAge(<span class="number">22</span>);</span><br><span class="line">        user.setId(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UserMapper mapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">int</span> result = mapper.update(user);</span><br><span class="line">            session.commit();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//操作结束，关闭session</span></span><br><span class="line">            session.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SqlSession session = before();</span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//执行查询操作，将查询结果自动封装成List&lt;User&gt;返回</span></span><br><span class="line">        List&lt;User&gt; users = mapper.getAll();</span><br><span class="line">        System.out.println(users);</span><br><span class="line">        session.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> &emsp;&emsp;以上的相关代码是全部测试通过的，使用MyBatis对表执行CRUD操作的内容基本就是这些。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 字节流</title>
      <link href="/blog/2017/09/26/Java/9/"/>
      <url>/blog/2017/09/26/Java/9/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;在Java的I/O类库中，总共有4种类型的操作。其中java.io.InputStream和java.io.OutputStream分别表示字节输入流和字节输出流，它们都是抽象类，不能实例化，数据流中的最小单位是字节，所以叫做字节流。在这里，只介绍字节流的概念和操作。其他I/O流的概念请参考<a href="/2017/09/15/Java/6">Java IO 工作机制</a>。<br><img data-src="http://dysmorsel.oss-cn-beijing.aliyuncs.com/blog/images/java%E5%AD%97%E8%8A%82%E6%B5%81.png" alt="字节流"></p>   <a id="more"></a><h1 id="InputStream中的读取数据的方法"><a href="#InputStream中的读取数据的方法" class="headerlink" title="InputStream中的读取数据的方法"></a>InputStream中的读取数据的方法</h1><div class="table-container"><table><thead><tr><th>序号</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>int read()</td><td>从输入流中读取数据的下一个字节。</td></tr><tr><td>2</td><td>int read(byte[] b)</td><td>从输入流中读取一定数量的字节，并将其存储在缓冲区数组 b 中。</td></tr><tr><td>3</td><td>int read(byte[] b, int off, int len)</td><td>将输入流中最多 len 个数据字节读入 byte 数组。</td></tr><tr><td>4</td><td>int available()</td><td>返回此输入流下一个方法调用可以不受阻塞地从此输入流读取（或跳过）的估计字节数。</td></tr><tr><td>5</td><td>void mark(int readlimit)</td><td>在此输入流中标记当前的位置。</td></tr><tr><td>6</td><td>void close()</td><td>关闭此输入流并释放与该流关联的所有系统资源。</td></tr></tbody></table></div><p>&emsp;&emsp;方法的详细信息请参考<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh/java/io/InputStream.html" target="_blank" rel="noopener">API</a>。</p><h1 id="InputStream代码演示"><a href="#InputStream代码演示" class="headerlink" title="InputStream代码演示"></a>InputStream代码演示</h1><h2 id="字节数组输入流ByteArrayInputStream"><a href="#字节数组输入流ByteArrayInputStream" class="headerlink" title="字节数组输入流ByteArrayInputStream"></a>字节数组输入流ByteArrayInputStream</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String str = <span class="string">"abcdefg"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] bytes = str.getBytes();<span class="comment">//字符串转换成字节数组</span></span><br><span class="line"></span><br><span class="line">    ByteArrayInputStream bs = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    <span class="keyword">int</span> data = bs.read(); <span class="comment">//从字节数组输入流读取字节</span></span><br><span class="line">    <span class="keyword">while</span> (data!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> upper = (<span class="keyword">char</span>) Character.toUpperCase(data);</span><br><span class="line">        System.out.print(upper+<span class="string">" "</span>);</span><br><span class="line">        data=bs.read();</span><br><span class="line">    &#125;</span><br><span class="line">    bs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：A B C D E F G</p><h2 id="文件输入流FileInputStream代码演示"><a href="#文件输入流FileInputStream代码演示" class="headerlink" title="文件输入流FileInputStream代码演示"></a>文件输入流FileInputStream代码演示</h2><p>&emsp;&emsp;首先新建一个txt文件夹，里面写入abcdefg。然后利用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"test.txt"</span>);</span><br><span class="line">    FileInputStream fs = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">8</span>];</span><br><span class="line">    fs.read(bytes);<span class="comment">//从文件输入流读入字节，并输出到字节数组</span></span><br><span class="line">    ByteArrayInputStream bs = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    <span class="keyword">int</span> data = bs.read(); <span class="comment">//从字节数组输入流读取字节</span></span><br><span class="line">    <span class="keyword">while</span> (data!=-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> upper = (<span class="keyword">char</span>) Character.toUpperCase(data);</span><br><span class="line">        System.out.print(upper+<span class="string">" "</span>);</span><br><span class="line">        data=bs.read();</span><br><span class="line">    &#125;</span><br><span class="line">    bs.close();</span><br><span class="line">    fs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：A B C D E F G<br>&emsp;&emsp;这里我们只简单介绍常用的两种输入流，其他输入流的概念较为复杂，这里就不多说。</p><h1 id="OutputStream中的写入数据的方法"><a href="#OutputStream中的写入数据的方法" class="headerlink" title="OutputStream中的写入数据的方法"></a>OutputStream中的写入数据的方法</h1><div class="table-container"><table><thead><tr><th>序号</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>void close()</td><td>关闭此输出流并释放与此流有关的所有系统资源。</td></tr><tr><td>2</td><td>void flush()</td><td>刷新此输出流并强制写出所有缓冲的输出字节。</td></tr><tr><td>3</td><td>void write(byte[] b)</td><td>将 b.length 个字节从指定的 byte 数组写入此输出流。</td></tr><tr><td>4</td><td>void write(byte[] b, int off, int len)</td><td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流。</td></tr><tr><td>5</td><td>abstract  void write(int b)</td><td>将指定的字节写入此输出流。</td></tr></tbody></table></div><p>&emsp;&emsp;方法的详细信息请参考<a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh/java/io/OutputStream.html" target="_blank" rel="noopener">API</a>。</p><h1 id="OutputStream代码演示"><a href="#OutputStream代码演示" class="headerlink" title="OutputStream代码演示"></a>OutputStream代码演示</h1><h2 id="字节数组输出流ByteArrayOutputStreamd代码演示"><a href="#字节数组输出流ByteArrayOutputStreamd代码演示" class="headerlink" title="字节数组输出流ByteArrayOutputStreamd代码演示"></a>字节数组输出流ByteArrayOutputStreamd代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream bs = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    String s = <span class="string">"test OutputStream"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">    bs.write(bytes); <span class="comment">//将指定的byte数组写到字节数组输出流中</span></span><br><span class="line">    System.out.println(bs.toString());<span class="comment">//将字节数组输出流内容转换成字符串输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：test OutputStream</p><h2 id="文件输出流FileInputStream代码演示"><a href="#文件输出流FileInputStream代码演示" class="headerlink" title="文件输出流FileInputStream代码演示"></a>文件输出流FileInputStream代码演示</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    String s = <span class="string">"test OutputStream"</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s.getBytes();</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"test.txt"</span>,<span class="keyword">true</span>);<span class="comment">//创建一个输出流，后面一个参数true表示追加，原有内容不会被清除,默认为false</span></span><br><span class="line">    fos.write(bytes);<span class="comment">//把字节数组bytes的内容通过输出流写到指定文件</span></span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;查看文件，可以发现文件内容增加了test OutputStream内容。<br>&emsp;&emsp;最后我们可以发现，大部分字节输入流输出流的操作原理基本一致，只要掌握好各种基本类型的操作，理解其父类InputStream和OutputStream的常用方法，问题就能得到解决。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java URL处理</title>
      <link href="/blog/2017/09/24/Java/8/"/>
      <url>/blog/2017/09/24/Java/8/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>&emsp;&emsp;URL（Uniform Resource Locator）中文名为统一资源定位符，有时也被俗称为网页地址。表示为互联网上的资源，如网页或者FTP地址。</p><p> URL可以分为如下几部分：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protocol://host:port/path?query<span class="comment">#fragment</span></span><br></pre></td></tr></table></figure><p>protocol(协议)可以是HTTP、HTTPS、FTP、和File，host为域名，post为端口号，path为  文件路径及文件夹。<br>     <a id="more"></a></p><h1 id="URL类方法"><a href="#URL类方法" class="headerlink" title="URL类方法"></a>URL类方法</h1><ul><li>在java.net包中定义了URL类，该类用来处理有关URL的内容。对于URL类的创建和使用，下面分别进行介绍。</li></ul><div class="table-container"><table><thead><tr><th>构造方法</th><th>描述</th></tr></thead><tbody><tr><td>public URL(String protocol, String host, int port, String file)</td><td>通过给定的参数(协议、主机名、端口号、文件名)创建URL。</td></tr><tr><td>public URL(String protocol, String host, String file)</td><td>通过给定的参数(协议、主机名、文件名)创建URL。使用默认的端口号</td></tr><tr><td>public URL(String protocol, String host, int port, String file, URLStreamHandler handler)</td><td>根据指定的 protocol、host、port 号、file 和 handler 创建 URL 对象。</td></tr><tr><td>public URL(String spec)</td><td>根据 String 表示形式创建 URL 对象。</td></tr></tbody></table></div><ul><li>URL类中包含了很多方法用于访问URL的各个部分，具体方法及描述如下：</li></ul><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public String getPath()</td><td>返回URL路径部分</td></tr><tr><td>public String getQuery</td><td>返回URL查询部分</td></tr><tr><td>public String getAuthority()</td><td>获取此 URL 的授权部分</td></tr><tr><td>public int getPort()</td><td>返回URL端口部分</td></tr><tr><td>public int getDefaultPort()</td><td>返回URL默认号</td></tr><tr><td>public String getProtocol()</td><td>返回URL的协议</td></tr><tr><td>public String getHost()</td><td>返回URL的主机</td></tr><tr><td>public String getFile()</td><td>返回URL文件名部分</td></tr><tr><td>public String getRef()</td><td>获取此 URL 的锚点（也称为”引用”）</td></tr><tr><td>public String UserInfo</td><td>获取此 URL 的 userInfo 部分</td></tr><tr><td>public URLConnection openConnection()</td><td>打开一个URL连接，并运行客户端访问资源</td></tr></tbody></table></div><h1 id="URL类方法实例"><a href="#URL类方法实例" class="headerlink" title="URL类方法实例"></a>URL类方法实例</h1><ul><li>下面用百度主页演示URL类中的方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.baidu.com/index.html?language=cn"</span>);</span><br><span class="line">        System.out.println(<span class="string">"URL 为："</span> + url.toString());</span><br><span class="line">        System.out.println(<span class="string">"协议为："</span> + url.getProtocol());</span><br><span class="line">        System.out.println(<span class="string">"验证信息："</span> + url.getAuthority());</span><br><span class="line">        System.out.println(<span class="string">"文件名及请求参数："</span> + url.getFile());</span><br><span class="line">        System.out.println(<span class="string">"主机名："</span> + url.getHost());</span><br><span class="line">        System.out.println(<span class="string">"路径："</span> + url.getPath());</span><br><span class="line">        System.out.println(<span class="string">"端口："</span> + url.getPort());</span><br><span class="line">        System.out.println(<span class="string">"默认端口："</span> + url.getDefaultPort());</span><br><span class="line">        System.out.println(<span class="string">"请求参数："</span> + url.getQuery());</span><br><span class="line">        System.out.println(<span class="string">"定位位置："</span> + url.getRef());</span><br></pre></td></tr></table></figure><ul><li>运行结果为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">URL 为：https:<span class="comment">//www.baidu.com/index.html?language=cn</span></span><br><span class="line">协议为：https</span><br><span class="line">验证信息：www.baidu.com</span><br><span class="line">文件名及请求参数：/index.html?language=cn</span><br><span class="line">主机名：www.baidu.com</span><br><span class="line">路径：/index.html</span><br><span class="line">端口：-<span class="number">1</span></span><br><span class="line">默认端口：<span class="number">443</span></span><br><span class="line">请求参数：language=cn</span><br><span class="line">定位位置：<span class="keyword">null</span></span><br></pre></td></tr></table></figure><h1 id="URLConnections-类方法"><a href="#URLConnections-类方法" class="headerlink" title="URLConnections 类方法"></a>URLConnections 类方法</h1><p>URL类中openConnection()返回一个 java.net.URLConnection类。<br>例如：</p><ul><li><p>如果你连接HTTP协议的URL, openConnection() 方法返回 HttpURLConnection 对象。</p></li><li><p>如果你连接的URL为一个JAR文件, openConnection() 方法将返回 JarURLConnection 对象。</p></li><li>等等…</li></ul><p>URLConnections方法列表：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Object getContent()</td><td>检索URL链接内容</td></tr><tr><td>Object getContent(Class[] classes)</td><td>检索URL链接内容</td></tr><tr><td>String getContentEncoding()</td><td>返回头部 content-encoding 字段值。</td></tr><tr><td>int getContentLength()</td><td>返回头部 content-length字段值</td></tr><tr><td>String getContentType()</td><td>返回头部 content-type 字段值</td></tr><tr><td>int getLastModified()</td><td>返回头部 last-modified 字段值。</td></tr><tr><td>long getExpiration()</td><td>返回头部 expires 字段值。</td></tr><tr><td>long getIfModifiedSince()</td><td>返回对象的 ifModifiedSince 字段值。</td></tr><tr><td>public InputStream getInputStream()</td><td>返回URL的输入流，用于读取资源</td></tr><tr><td>public OutputStream getOutputStream()</td><td>返回URL的输出流, 用于写入资源。</td></tr><tr><td>public URL getURL()</td><td>返回 URLConnection 对象连接的URL</td></tr></tbody></table></div><h1 id="URLConnections-类方法实例"><a href="#URLConnections-类方法实例" class="headerlink" title="URLConnections 类方法实例"></a>URLConnections 类方法实例</h1><p>下面用百度主页演示URLConnection方法，采用HTTPS协议。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"https://www.baidu.com/index.html"</span>);</span><br><span class="line">URLConnection connection = url.openConnection();</span><br><span class="line"></span><br><span class="line">InputStream is = connection.getInputStream();</span><br><span class="line"></span><br><span class="line">BufferedReader buffer = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(is));</span><br><span class="line"></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">String content ;</span><br><span class="line"><span class="keyword">while</span> ((content=buffer.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    sb.append(content);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sb);</span><br></pre></td></tr></table></figure><p>编译运行后，会输出百度首页<code>https://www.baidu.com/index.html</code>的html内容。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis 配置详解</title>
      <link href="/blog/2017/09/17/Java/7/"/>
      <url>/blog/2017/09/17/Java/7/</url>
      
        <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li><p>将MyBatis-X.X.X.jar 文件置于classpath。</p></li><li><p>使用Maven构建dependency代码如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="构建SqlSessionFactory"><a href="#构建SqlSessionFactory" class="headerlink" title="构建SqlSessionFactory"></a>构建SqlSessionFactory</h1><ul><li>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的，在构建SqlSessionFactory时，可以使用两种构建方式，分别是xml配置文件构建和Java代码构建。</li></ul><h2 id="xml构建："><a href="#xml构建：" class="headerlink" title="xml构建："></a>xml构建：</h2><ul><li>xml配置文件如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>注入xml配置文件：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line"><span class="comment">//Resources中的getResourceAsStream方法使用ClassLoader中的getResourceAsStream</span></span><br><span class="line">InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="comment">//InputStream inputStream = &#123;classname&#125;.class.getClassLoader().getResourceAsStream(resource);</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br></pre></td></tr></table></figure><h2 id="Java构建："><a href="#Java构建：" class="headerlink" title="Java构建："></a>Java构建：</h2><ul><li>Java配置代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注入属性值</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">properties.setProperty(<span class="string">"driver"</span>,<span class="string">"com.mysql.jdbc.Driver"</span>); properties.setProperty(<span class="string">"url"</span>,<span class="string">"jdbc:mysql://localhost:3306/mybatis"</span>);</span><br><span class="line">properties.setProperty(<span class="string">"username"</span>,<span class="string">"root"</span>);</span><br><span class="line">properties.setProperty(<span class="string">"password"</span>,<span class="string">"$&#123;password&#125;"</span>);</span><br><span class="line"><span class="comment">//创建pooled连接池</span></span><br><span class="line">PooledDataSourceFactory pooledDataSourceFactory = <span class="keyword">new</span> PooledDataSourceFactory();</span><br><span class="line">pooledDataSourceFactory.setProperties(properties);</span><br><span class="line">DataSource dataSource = pooledDataSourceFactory.getDataSource();</span><br><span class="line"><span class="comment">//注入事务管理</span></span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line"><span class="comment">//创建mybatis加载环境类</span></span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>,transactionFactory,dataSource);</span><br><span class="line"><span class="comment">//创建全局构造类</span></span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br></pre></td></tr></table></figure><ul><li>注入Java配置代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;注：xml构建方法和Java构建方法的结果是完全一致的，并且xml中节点代表的意义也与代码中各种类型代表的意义一致，只不过是两种不同的方法而已。对于不希望使用xml文件的人来说，可以使用Java代码配置。同时在这里我们可以发现，使用xml文件来配置MyBatis的Configuration，在一定程度上比使用Java代码更加简洁，因此更推荐使用xml文件配置Configuration。</p><h1 id="定义表所对应的实体类"><a href="#定义表所对应的实体类" class="headerlink" title="定义表所对应的实体类"></a>定义表所对应的实体类</h1><p>&emsp;&emsp;数据表的结构如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">user</span>(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">22</span>),</span><br><span class="line">  age <span class="built_in">INT</span>(<span class="number">10</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;定义与之对应的实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="从SqlSessionFactory中获取SqlSession"><a href="#从SqlSessionFactory中获取SqlSession" class="headerlink" title="从SqlSessionFactory中获取SqlSession"></a>从SqlSessionFactory中获取SqlSession</h1><ul><li>顾名思义，有了SqlSessionFactory，我们就可以从中获取SqlSession。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SqlSession session = sqlSessionFactory.openSession();</span><br></pre></td></tr></table></figure><ul><li>SqlSession 完全包含了面向数据库执行 SQL 命令所需的所有方法。</li><li>可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。</li></ul><h1 id="构建映射器Mapper"><a href="#构建映射器Mapper" class="headerlink" title="构建映射器Mapper"></a>构建映射器Mapper</h1><h2 id="xml配置："><a href="#xml配置：" class="headerlink" title="xml配置："></a>xml配置：</h2><ul><li>直接在mybatis-config.xml文件configuration节点内添加mapper节点：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--resource指向mapper映射器配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"mapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 也可以指向映射器的接口类型，或者其url --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.mapping.UserMapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file://mapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>随后新建mapper.xml作为mapper的映射文件，并在mapper中写入数据库操作语句。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定命名空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"domain.userMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUser"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span> <span class="attr">resultType</span>=<span class="string">"domain.User"</span>&gt;</span></span><br><span class="line">        SELECT * FROM user WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>也可以新建一个接口文件做为mapper的接口，如下所示：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> mapping;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> domain.User;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"><span class="comment">//在注解中写入数据库操作语句</span></span><br><span class="line">    <span class="meta">@Select</span>(value = <span class="string">"SELECT * FROM user WHERE id = #&#123;id&#125; "</span>)</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java配置："><a href="#Java配置：" class="headerlink" title="Java配置："></a>Java配置：</h2><ul><li>通过自己创建configuration来配置：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加映射器，这里与xml配置不同的是，在配置SqlSessionFactory时便已经将映射器的接口文件添加进去</span></span><br><span class="line">configuration.addMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//或者添加这个接口的包名</span></span><br><span class="line">configuration.addMapper(<span class="string">"com.mapping"</span>);</span><br><span class="line"><span class="comment">//建立SqlSessionFactory</span></span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在这里我们可以发现，使用xml配置映射器方式更多，且java代码配置无法添加xml文件做为映射器，比较下来有一定的局限性。</p><h1 id="使用已经映射的SQL语句"><a href="#使用已经映射的SQL语句" class="headerlink" title="使用已经映射的SQL语句"></a>使用已经映射的SQL语句</h1><p>&emsp;&emsp;我们利用SqlSession来使用已经在映射器中映射的SQL语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定XML配置中mapper配置文件中的命名空间和id</span></span><br><span class="line">String statement = <span class="string">"domain.userMapper.getUser"</span>;</span><br><span class="line"></span><br><span class="line">User user = session.selectOne(statement,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Java配置中已配置的UserMapper接口</span></span><br><span class="line">UserMapper mapper = session.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">User user = mapper.findById(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;最后使用映射器中的方法进行数据库的操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java IO 工作机制(转)</title>
      <link href="/blog/2017/09/15/Java/6/"/>
      <url>/blog/2017/09/15/Java/6/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-的-I-O-类库的基本架构"><a href="#Java-的-I-O-类库的基本架构" class="headerlink" title="Java 的 I/O 类库的基本架构"></a>Java 的 I/O 类库的基本架构</h1><ul><li>Java 的 I/O 操作类在包java.io下，大概有将近 80 个类，但是这些类大概可以分成四组，分别是：<ul><li>基于字节操作的 I/O 接口：InputStream 和 OutputStream</li><li>基于字符操作的 I/O 接口：Writer 和 Reader</li><li>基于磁盘操作的 I/O 接口：File</li><li>基于网络操作的 I/O 接口：Socket <a id="more"></a></li></ul></li></ul><h2 id="基于字节的-I-O-操作接口"><a href="#基于字节的-I-O-操作接口" class="headerlink" title="基于字节的 I/O 操作接口"></a>基于字节的 I/O 操作接口</h2><ul><li>基于字节的 I/O 操作接口输入和输出分别是：InputStream 和 OutputStream，InputStream 输入流的类继承层次如下图所示：</li><li><p>InputStream 相关类层次结构</p><p>  <img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image002.png" alt="image"></p></li><li><p>OutputStream 相关类层次结构</p><p>  <img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image004.png" alt="image"></p></li></ul><h2 id="基于字符的-I-O-操作接口"><a href="#基于字符的-I-O-操作接口" class="headerlink" title="基于字符的 I/O 操作接口"></a>基于字符的 I/O 操作接口</h2><p>&emsp;&emsp;我们的程序中通常操作的数据都是以字符形式，为了操作方便当然要提供一个直接写字符的 I/O 接口,下图是写字符的 I/O 操作接口涉及到的类，Writer类提供了一个抽象方法<strong>write(char cbuf[], int off, int len)</strong>由子类去实现。</p><ul><li>Writer相关类层次结构</li></ul><p><img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image006.png" alt="image"><br>&emsp;&emsp;读字符的操作接口也有类似的结构,如下图：</p><ul><li>Reader 类层次结构</li></ul><p><img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image008.png" alt="image"><br>&emsp;&emsp;读字符的操作接口中也是<strong>int read(char cbuf[], int off, int len)</strong>，返回读到的n个字节数，不管是Writer还是Reader类它们都只定义了读取或写入的数据字符的方式，也就是怎么写或读，但是并没有规定数据要写到哪去，写到哪去就是我们后面要讨论的基于磁盘和网络的工作机制。</p><h2 id="字节与字符的转化接口"><a href="#字节与字符的转化接口" class="headerlink" title="字节与字符的转化接口"></a>字节与字符的转化接口</h2><ul><li>字符解码相关类结构</li></ul><p><img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image011.jpg" alt="image"></p><p>&emsp;&emsp;InputStreamReader 类是字节到字符的转化桥梁，InputStream到 Reader的过程要指定编码字符集，否则将采用操作系统默认字符集，很可能会出现乱码问题。StreamDecoder正是完成字节到字符的解码的实现类。</p><ul><li>读取文件示例代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">          StringBuffer str = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">          <span class="keyword">char</span>[] buf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">          FileReader f = <span class="keyword">new</span> FileReader(<span class="string">"file"</span>);</span><br><span class="line">          <span class="keyword">while</span>(f.read(buf)&gt;<span class="number">0</span>)&#123;</span><br><span class="line">              str.append(buf);</span><br><span class="line">          &#125; </span><br><span class="line">          str.toString();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;FileReader 类就是按照上面的工作方式读取文件的，FileReader 是继承了 InputStreamReader 类，实际上是读取文件流，然后通过 StreamDecoder 解码成 char，只不过这里的解码字符集是默认字符集。</p><ul><li>字符编码相关类结构</li></ul><p><img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image013.jpg" alt="image"></p><p>&emsp;&emsp;通过 OutputStreamWriter 类完成，字符到字节的编码过程，由 StreamEncoder 完成编码过程。</p><h2 id="磁盘-I-O-工作机制"><a href="#磁盘-I-O-工作机制" class="headerlink" title="磁盘 I/O 工作机制"></a>磁盘 I/O 工作机制</h2><p>&emsp;&emsp;前面介绍了基本的 Java I/O 的操作接口，这些接口主要定义了如何操作数据，以及介绍了操作两种数据结构：字节和字符的方式。还有一个关键问题就是数据写到何处，其中一个主要方式就是将数据持久化到物理磁盘，下面将介绍如何将数据持久化到物理磁盘的过程。<br>&emsp;&emsp;我们知道数据在磁盘的唯一最小描述就是文件，也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。值得注意的是Java中通常的File并不代表一个真实存在的文件对象，当你通过指定一个路径描述符时，它就会返回一个代表这个路径相关联的一个虚拟对象，这个可能是一个真实存在的文件或者是一个包含多个文件的目录。为何要这样设计？<strong>因为大部分情况下，我们并不关心这个文件是否真的存在，而是关心这个文件到底如何操作。</strong>例如我们手机里通常存了几百个朋友的电话号码，但是我们通常关心的是我有没有这个朋友的电话号码，或者这个电话号码是什么，但是这个电话号码到底能不能打通，我们并不是时时刻刻都去检查，而只有在真正要给他打电话时才会看这个电话能不能用。也就是使用这个电话记录要比打这个电话的次数多很多。<br>&emsp;&emsp;何时真正会要检查一个文件存不存？就是在真正要读取这个文件时，例如 FileInputStream类都是操作一个文件的接口，注意到在创建一个 FileInputStream对象时，会创建一个FileDescriptor对象，其实这个对象就是真正代表一个存在的文件对象的描述，当我们在操作一个文件对象时可以通过getFD()方法获取真正操作的与底层操作系统关联的文件描述。例如可以调用FileDescriptor.sync()方法将操作系统缓存中的数据强制刷新到物理磁盘中。<br>&emsp;&emsp;下面以上述代码块的程序为例，介绍下如何从磁盘读取一段文本字符。如下图所示：<br><img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image015.jpg" alt="image"><br>&emsp;&emsp;当传入一个文件路径，将会根据这个路径创建一个File对象来标识这个文件，然后将会根据这个File对象创建真正读取文件的操作对象，这时将会真正创建一个关联真实存在的磁盘文件的文件描述符FileDescriptor，通过这个对象可以直接控制这个磁盘文件。由于我们需要读取的是字符格式，所以需要StreamDecoder类将byte解码为char格式，至于如何从磁盘驱动器上读取一段数据，由操作系统帮我们完成。至于操作系统是如何将数据持久化到磁盘以及如何建立数据结构需要根据当前操作系统使用何种文件系统来回答，至于文件系统的相关细节可以参考另外的文章。</p><h2 id="Java-Socket的工作机制"><a href="#Java-Socket的工作机制" class="headerlink" title="Java Socket的工作机制"></a>Java Socket的工作机制</h2><p>&emsp;&emsp;Socket这个概念没有对应到一个具体的实体，它是描述计算机之间完成相互通信一种抽象功能。打个比方，可以把Socket比作为两个城市之间的交通工具，有了它，就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。Socket也一样，也有多种。大部分情况下我们使用的都是基于TCP/IP的流套接字，它是一种稳定的通信协议。<br>下图是典型的基于 Socket 的通信的场景：<br><img data-src="https://www.ibm.com/developerworks/cn/java/j-lo-javaio/image017.jpg" alt="image"><br>&emsp;&emsp;主机A的应用程序要能和主机B的应用程序通信，必须通过Socket建立连接，而建立Socket连接必须需要底层TCP/IP协议来建立TCP连接。建立TCP连接需要底层IP协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据IP地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过TCP或UPD的地址也就是端口号来指定。这样就可以通过一个Socket实例唯一代表一个主机上的一个应用程序的通信链路了。</p><h3 id="建立通信链路"><a href="#建立通信链路" class="headerlink" title="建立通信链路"></a>建立通信链路</h3><p>&emsp;&emsp;当客户端要与服务端通信，客户端首先要创建一个Socket实例，操作系统将为这个Socket实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建Socket实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket实例对象将创建完成，否则将抛出IOException错误。<br>&emsp;&emsp;与之对应的服务端将创建一个ServerSocket实例ServerSocket创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为ServerSocket实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用accept()方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到ServerSocket实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的Socket实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的Socket实例才会返回，并将这个Socket实例对应的数据结构从未完成列表中移到已完成列表中。所以ServerSocket所关联的列表中每个数据结构，都代表与一个客户端的建立的TCP连接。</p><h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>&emsp;&emsp;传输数据是我们建立连接的主要目的，如何通过Socket传输数据，下面将详细介绍。<br>&emsp;&emsp;当连接已经建立成功，服务端和客户端都会拥有一个Socket实例，每个Socket实例都有一个InputStream和OutputStream正是通过这两个对象来交换数据。同时我们也知道网络I/O都是以字节流传输的。当Socket对象创建时，操作系统将会为InputStream和OutputStream分别分配一定大小的缓冲区，数据的写入和读取都是通过这个缓存区完成的。写入端将数据写到OutputStream对应的 SendQ 队列中，当队列填满时，数据将被发送到另一端InputStream的RecvQ队列中，如果这时RecvQ已经满了，那么OutputStream的write方法将会阻塞直到RecvQ队列有足够的空间容纳SendQ发送的数据。值得特别注意的是，这个缓存区的大小以及写入端的速度和读取端的速度非常影响这个连接的数据传输效率，由于可能会发生阻塞，所以网络I/O与磁盘I/O在数据的写入和读取还要有一个协调的过程，如果两边同时传送数据时可能会产生死锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 进阶 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类详解</title>
      <link href="/blog/2017/09/15/Java/5/"/>
      <url>/blog/2017/09/15/Java/5/</url>
      
        <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p><img data-src="http://dysmorsel.oss-cn-beijing.aliyuncs.com/blog/images/collection1.png" alt="Collection"><br><img data-src="http://dysmorsel.oss-cn-beijing.aliyuncs.com/blog/images/collection2.png" alt="Map"></p><a id="more"></a><h1 id="Colleciton接口"><a href="#Colleciton接口" class="headerlink" title="Colleciton接口"></a>Colleciton接口</h1><h2 id="Set和List：继承Collection"><a href="#Set和List：继承Collection" class="headerlink" title="Set和List：继承Collection"></a>Set和List：继承Collection</h2><ul><li>Set和List对比：<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li></ul></li><li>Set和List具体子类：<ul><li>Set<ul><li>HashSet：以哈希表的形式存放元素，插入删除速度很快。</li></ul></li><li>List<ul><li>ArrayList：动态数组</li><li>LinkedList：链表、队列、堆栈。</li></ul></li><li><strong>Linked 改快读慢</strong></li><li><strong>Array 读快改慢</strong></li><li><strong>Hash 两者之间</strong></li></ul></li></ul><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><ul><li>说明：Map 接口不是 Collection 接口的继承。而是从自己的用于维护键-值关联的接口层次结构入手。按定义，Map接口储存一组成对的键-值对象，提供key（键）到value（值）的映射，Map中的key不要求有序，不允许重复。value同样不要求有序，但可以重复。</li><li>我们可以把这个接口方法分成三组操作：改变、查询和提供可选视图。</li><li>改变操作允许您从映射中添加和除去键-值对。键和值都可以为 null。但是，您不能把Map 作为一个键或值添加给自身。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">put</span><span class="params">(Object key, Object value)</span><span class="comment">//将指定的值与此映射中的指定键关联,返回值是被替换的值。</span></span></span><br><span class="line"><span class="function">Object <span class="title">remove</span><span class="params">(Object key)</span><span class="comment">//如果存在一个键的映射关系，则将其从此映射中移除</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map mapping)</span><span class="comment">//从指定映射中将所有映射关系复制到此映射中</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span><span class="comment">// 从此映射中移除所有映射关系</span></span></span><br></pre></td></tr></table></figure><ul><li>查询操作允许您检查映射内容：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">get</span><span class="params">(Object key)</span><span class="comment">//返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span><span class="comment">//如果此映射包含指定键的映射关系，则返回 true</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span><span class="comment">//如果此映射将一个或多个键映射到指定值，则返回 true。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span><span class="comment">//返回此映射中的键-值映射关系数。</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span><span class="comment">//如果此映射未包含键-值映射关系，则返回 true。</span></span></span><br></pre></td></tr></table></figure><ul><li>最后一组方法允许您把键或值的组作为集合来处理。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Set <span class="title">keySet</span><span class="params">()</span><span class="comment">//映射中键的集合必须是唯一的</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection <span class="title">values</span><span class="params">()</span><span class="comment">//映射中值的集合可能不唯一</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set <span class="title">entrySet</span><span class="params">()</span><span class="comment">//返回一个实现 Map.Entry 接口的元素 Set</span></span></span><br></pre></td></tr></table></figure><ul><li>HashMap 类和 TreeMap 类<ul><li>在Map 中插入、删除和定位元素，HashMap 是最好的选择。</li><li>但如果您要按顺序遍历键，那么TreeMap 会更好。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java核心类</title>
      <link href="/blog/2017/09/15/Java/4/"/>
      <url>/blog/2017/09/15/Java/4/</url>
      
        <content type="html"><![CDATA[<h1 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h1><h2 id="equals-方法"><a href="#equals-方法" class="headerlink" title="equals() 方法"></a>equals() 方法</h2><ul><li>equals()方法是用来判断其他的对象是否和该对象相等. </li><li>String 、Math、Integer、Double等这些封装类在使用equals()方法时，已经覆盖了object类的equals()方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">      String anotherString = (String)anObject;</span><br><span class="line">      <span class="keyword">int</span> n = count;</span><br><span class="line">      <span class="keyword">if</span> (n == anotherString.count) &#123;</span><br><span class="line">        <span class="keyword">char</span> v1[] = value;</span><br><span class="line">        <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">        <span class="keyword">int</span> i = offset;</span><br><span class="line">        <span class="keyword">int</span> j = anotherString.offset;</span><br><span class="line">        <span class="keyword">while</span> (n– != <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (v1[i++] != v2[j++])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>很明显，这是进行的内容比较，而已经不再是地址的比较。依次类推Math、Integer、Double等这些类都是重写了equals()方法的，从而进行的是内容的比较。</li><li>性质<ul><li>自反性（reflexive）。对于任意不为null的引用值x，x.equals(x)一定是true。</li><li>对称性（symmetric）。对于任意不为null的引用值x和y，当且仅当x.equals(y)是true时，y.equals(x)也是true。</li><li>传递性（transitive）。对于任意不为null的引用值x、y和z，如果x.equals(y)是true，同时y.equals(z)是true，那么x.equals(z)一定是true。</li><li>一致性（consistent）。对于任意不为null的引用值x和y，如果用于equals比较的对象信息没有被修改的话，多次调用时x.equals(y)要么一致地返回true要么一致地返回false。</li><li>需要注意的是当equals()方法被override时，hashCode()也要被override。按照一般hashCode()方法的实现来说，相等的对象，它们的hash code一定相等。</li></ul></li></ul><h2 id="hashCode-方法"><a href="#hashCode-方法" class="headerlink" title="hashCode() 方法"></a>hashCode() 方法</h2><ul><li>hashCode()方法给对象返回一个hash code值。这个方法被用于hash tables，例如HashMap。</li><li>Java对象的eqauls方法和hashCode方法是这样规定的：<ol><li>相等（相同）的对象必须具有相等的哈希码（或者散列码）。</li><li>如果两个对象的hashCode相同，它们并不一定相同。</li></ol></li></ul><h1 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h1><ul><li>构造方法</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td>String()</td><td>创建一个空字符串对象</td></tr><tr><td style="text-align:center">2.</td><td>String(byte[] bytes)</td><td>使用一个字节数组来创建一个字符串的对象。</td></tr><tr><td style="text-align:center">3.</td><td>String(byte[] bytes,int offset, int length)</td><td>解码字节数组中指定部分</td></tr><tr><td style="text-align:center">4.</td><td>String(char[] value)</td><td>使用一个字符数组创建一个字符串对象。</td></tr><tr><td style="text-align:center">5.</td><td>String(char[] value,int offset, int length)</td><td>解码字符数组中指定部分</td></tr><tr><td style="text-align:center">6.</td><td>String(int[] codePoints,int offset,int length)</td><td>解码整数数组中指定部分</td></tr></tbody></table></div><ul><li>示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> [] bytes =&#123;<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    String hh = <span class="keyword">new</span> String(bytes);</span><br><span class="line">    <span class="comment">//从数组第一位解码，长度为2</span></span><br><span class="line">    String dd= <span class="keyword">new</span> String(bytes,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">      System.out.println(hh);</span><br><span class="line">      System.out.println(dd);</span><br></pre></td></tr></table></figure><h1 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h1><ul><li>定义：由于String的内容是不可变的，一旦修改马上会创建一个对象，所以为了避免导致String对象泛滥，在频繁改变字符串对象的应用中，需要使用可变的字符串缓冲区类。</li><li>实质：StringBuffer底层是一个字符串数组，默认缓冲区的容量是16。如果字符串的长度不够，内存将自动 <strong>增长一倍</strong>，线程安全的所有的缓冲区操作方法都是同步的。效率很低。</li></ul><h1 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h1><ul><li><p>作用：获取系统属性</p></li><li><p>类中所有成员都是静态的，当要引用这些变量和方法的时候，System.属性 System.方法()</p></li><li>常用的方法：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1.</td><td>arraycopy(Object src,int srcPro,Object dest,int destPro，int length)</td><td>(源数组，源数组中的起始位置，目标数组，目标数组的起始位置，要复制数组的长度)</td></tr><tr><td style="text-align:center">2.</td><td>currentTimesMillis()</td><td>获取系统时间</td></tr><tr><td style="text-align:center">3.</td><td>exit(int status)</td><td>0:正常退出jvm  1：异常退出</td></tr><tr><td style="text-align:center">4.</td><td>gc()</td><td>建议jvm启动垃圾回收器回收垃圾</td></tr><tr><td style="text-align:center">5.</td><td>getenv(String name)</td><td>根据环境变量名获取环境变量</td></tr><tr><td style="text-align:center">6.</td><td>String getProperty(String name)</td><td>获取某个系统属性</td></tr></tbody></table></div><h1 id="Runtime类"><a href="#Runtime类" class="headerlink" title="Runtime类"></a>Runtime类</h1><ul><li>作用：该类描述当前应用程序的运行环境，一个应用程序只有一个运行环境</li><li>常用的方法：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>getRuntime()</td><td>返回当前应用程序的运行环境对象。</td></tr><tr><td style="text-align:center">2</td><td>exec(String command)</td><td>根据指定的路径执行对应的执行文件。</td></tr><tr><td style="text-align:center">3</td><td>freeMemory()</td><td>返回jvm中的空闲内存。（以字节为单位）</td></tr><tr><td style="text-align:center">4</td><td>maxMemory()</td><td>返回jvm中试图管理的最大内存</td></tr><tr><td style="text-align:center">5</td><td>totalMemory()</td><td>返回jvm中内存总量</td></tr></tbody></table></div><ul><li><p>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Runtime runtime = Runtime.getRuntime();</span><br><span class="line">       Process process = runtime.exec(<span class="string">"C:\\Windows\\notepad.exe"</span>);</span><br><span class="line">       <span class="comment">//Thread.sleep(3000);</span></span><br><span class="line">       process.destroy();</span><br><span class="line">       System.out.println(runtime.freeMemory());</span><br><span class="line">       System.out.println(runtime.maxMemory());</span><br><span class="line">       System.out.println(runtime.totalMemory());</span><br></pre></td></tr></table></figure></li></ul><h1 id="Math类"><a href="#Math类" class="headerlink" title="Math类"></a>Math类</h1><ul><li>常用的方法：</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">序号</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td>abs(double num)</td><td>取绝对值</td></tr><tr><td style="text-align:center">2</td><td>ceil(double num)</td><td>向上取整</td></tr><tr><td style="text-align:center">3</td><td>floor(double num)</td><td>向下取整</td></tr><tr><td style="text-align:center">4</td><td>round(double num)</td><td>四舍五入</td></tr><tr><td style="text-align:center">5</td><td>random（）</td><td>产生大于等于0.0 小于1.0的随机数Random 类可产生各种随机数</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 包装类详解</title>
      <link href="/blog/2017/09/15/Java/3/"/>
      <url>/blog/2017/09/15/Java/3/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)，有些地方也翻译为外覆类或数据类型类。</li><li>包装类均位于Java.lang包，包装类和基本数据类型的对应关系如下表所示：</li></ul><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr></tbody></table></div>  <a id="more"></a><ul><li>对于包装类说，这些类的用途主要包含两种：<ul><li>作为和基本数据类型对应的类类型存在，方便涉及到对象的操作。</li><li>包含每种基本数据类型的相关属性如最大值、最小值等，以及相关的操作方法。</li></ul></li><li>下面使用Integer类来介绍包装类的基本用法。</li></ul><h1 id="简单使用："><a href="#简单使用：" class="headerlink" title="简单使用："></a>简单使用：</h1><ul><li><p>1、实现int和Integer类之间的转换：</p><p>&emsp;&emsp;在实际转换时，使用Integer类的构造方法和Integer类内部的intValue方法实现这些类型之间的相互转换，实现的代码如下：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">Integer in = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//将int类型转换为Integer类型</span></span><br><span class="line">Integer in1 = <span class="keyword">new</span> Integer(n);</span><br><span class="line"><span class="comment">//将Integer类型的对象转换为int类型</span></span><br><span class="line"><span class="keyword">int</span> m = in.intValue();</span><br></pre></td></tr></table></figure><ul><li>2、其他常用转化方法如下：</li></ul><div class="table-container"><table><thead><tr><th>返回值</th><th>方法名</th><th>解释</th></tr></thead><tbody><tr><td>byte</td><td>byteValue()</td><td>将Integer转为byte类型</td></tr><tr><td>double</td><td>doubleValue()</td><td>转为double类型</td></tr><tr><td>float</td><td>floatValue()</td><td>转为float类型</td></tr></tbody></table></div><ul><li>3、与字符串相关的方法：<ul><li>parseInt方法：</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该方法的作用是将数字字符串转换为int数值。在以后的界面编程中，将字符串转换为对应的int数字是一种比较常见的操作。使用示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = “<span class="number">123</span>”;</span><br><span class="line"><span class="keyword">int</span> n = Integer.parseInt(s);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该方法实际上实现了字符串和int之间的转换，如果字符串都包含的不是都是数字字符，则程序执行将出现异常。</p><p>另外一个parseInt方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">parseInt</span><span class="params">(String s, <span class="keyword">int</span> radix)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;实现将字符串按照参数radix指定的进制转换为int。</p><ul><li>toString方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该方法的作用是将int类型转换为对应的String类型。</p><h1 id="装箱和拆箱"><a href="#装箱和拆箱" class="headerlink" title="装箱和拆箱"></a>装箱和拆箱</h1><ul><li>JDK自从1.5(5.0)版本以后，就引入了自动拆装箱的语法，也就是在进行基本数据类型和对应的包装类转换时，系统将自动进行，这将大大方便程序员的代码书写。</li><li>代码示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int类型会自动转换为Integer类型</span></span><br><span class="line"><span class="keyword">int</span> m = <span class="number">12</span>;</span><br><span class="line">Integer in = m;</span><br><span class="line"><span class="comment">//Integer类型会自动转换为int类型</span></span><br><span class="line"><span class="keyword">int</span> n = in;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java 类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell常用命令</title>
      <link href="/blog/2017/09/12/Linux/2/"/>
      <url>/blog/2017/09/12/Linux/2/</url>
      
        <content type="html"><![CDATA[<h3 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h3><ul><li>shell窗口<ul><li>登录系统后，打开终端。</li><li>通常在窗口前能看到$提示符。</li><li>用#提示符的命令是<em>root</em> 身份。   <a id="more"></a></li></ul></li><li>cat命令<ul><li>cat命令显示一个或多个文件的<strong>内容</strong>。</li></ul></li><li>标准输入输出<ul><li>Unix进程使用I/O；流来读写数据。</li></ul></li><li>基础命令<ul><li>ls命令<ul><li>ls命令显示指定目录的<strong>内容</strong>。默认参数是当前目录。</li><li>ls -l 显示详细的列表，ls -F显示文件类型信息。</li></ul></li><li>cp命令<ul><li>cp命令用来复制文件：$cp file1 file2</li><li>将多哥文件（file1…fileN）复制到目录dir：$file1…fileN dir</li></ul></li><li>mv命令<ul><li>mv命令用来重命名文件。<strong>与cp命令类似</strong>。</li></ul></li><li>touch命令<ul><li>touch命令用来创建文件。</li></ul></li><li>rm命令<ul><li>rm命令用来删除文件，<strong><em>文件一旦被删除通常无法恢复。</em></strong></li></ul></li><li>echo命令 <ul><li>echo命令将它的参数显示到标准输出。</li></ul></li></ul></li><li><strong>浏览目录</strong><ul><li>我们通过<strong>路径</strong>或<strong>路径名</strong>来访问文件。以/开头的路径叫绝对路径，如/usr/lib。</li><li>两个点代表一个目录上次目录。</li><li>cd命令<ul><li>cd命令用来设置当前<strong>工作目录</strong>。</li><li>如果不带参数，cd命令会返回你的<em>个人主目录</em>。</li></ul></li><li>mkdir命令<ul><li>mkdir命令用来创建新目录。</li></ul></li><li>rmdir命令<ul><li>rmdir命令用来删除目录。</li></ul></li><li>shell通配符<ul><li>shell可以使用<strong>通配符</strong>来匹配文件名和目录名。*代表任意字符和数字。</li><li>*at展开为所有以at开头的文件名。</li><li>at*展开为所有以at结尾的文件名。</li><li><em>at </em> 展开为所有包含at的文件名。</li></ul></li></ul></li><li>中间命令<ul><li>grep命令<ul><li>grep命令显示文件和输入流中和参数匹配的行。</li><li>该命令有两个比较重要的选项，一个是-l，一个是-v（反转匹配）。</li></ul></li><li>less命令<ul><li>less命令：用于查看大文件或者内容多到需要滚屏时。</li><li>B键查看上一屏，Q键退出。</li></ul></li><li>pwd命令：仅输出当前的工作目录名。</li><li>diff命令：用来查看两个文件直接的不同。</li><li>file命令：知道文件的格式信息。</li><li>find和locate命令<ul><li>find dir -name file -print ：找到文件在哪个目录。</li><li>locate：在系统创建的文件索引中查找文件。</li></ul></li><li>head和tail命令<ul><li>head命令显示文件的前10行内容，tail命令显示文件的最后10行内容。</li><li>可以<strong>使用-n选项</strong>来设置显示的行数。</li></ul></li><li>sort命令：将文件的行按字母顺序快速排序。</li></ul></li><li>更改密码和shell<ul><li>使用passwd命令来更改密码。</li></ul></li><li>dot文件：使用ls -a 命令来显示dot文件。</li><li>环境变量和shell变量<ul><li>shell中可以保存一些临时的变量，称作shell变量。</li><li>可以使用export命令来设置环境变量。</li></ul></li><li>命令路径<ul><li>PATH是一个特殊的环境变量，它定义了命令路径，或简称为路径。</li><li>可以设置PATH路径：<ol><li>$PATH=dir:$PATH :将路径dir加到PATH的最前面。</li><li>$PATH=$PATH:dir:将路径加到PATH的最后面。</li></ol></li></ul></li><li>特殊字符：可以参考网站<a href="http://www.catb.org/jargon/html/" target="_blank" rel="noopener">jargon File</a>.</li><li>命令行编辑：<br>|按键        | 操作       |<br>| :—————|—————-:|<br>|Ctrl-B      | 左移光标   |<br>|Ctrl-F      | 右移光标   |<br>|Ctrl-p      | 查看上一条命令|<br>|Ctrl-N      | 查看下一条命令|<br>|Ctrl-A      |移动光标至行首|<br>|Ctrl-E      |移动光标至行尾|<br>|Ctrl-W      |删除前一个词|<br>|Ctrl-U      |删除从光标至行首的内容|<br>|Ctrl-K      |删除从光标至行尾的内容|<br>|Ctrl-Y      |粘贴已经删除的文本|</li><li>文本编辑器</li><li>获取在线帮助 ：$man ls<ul><li>通过关键字查询：$man -k keyword</li><li>按序号来选择章节：$man 5 passwd</li></ul></li><li>shell输入输出<ul><li>将命令的执行结果输出到文件，可以使用重定向字符：$command&gt;file.</li><li>如果不想把原文件覆盖，可以使用&gt;&gt;将命令的输出结果加入到文件末尾：$command&gt;&gt;file.</li></ul></li><li>理解错误信息<ul><li>解析Unix的错误信息  </li><li>常见错误<ul><li>No such file or directory :访问一个不存在的文件或目录。</li><li>File exists：新建的文件的名称和现有的文件或者目录重名。</li><li>Not a directory,Is a directory:把文件当做目录或者反之把目录当文件。</li><li>No space left on device:说明硬盘空间不足。</li><li>Permission denide:权限不足。</li><li>Operation not permitted:试图终止一个无权终止的进程时。</li><li>Segmentation fault,Bus error:分路故障，总线错误。</li></ul></li><li>查看和操作进程<ul><li>$ps :查看正在运行的进程。</li><li>$kill pid :终止进程。</li></ul></li><li>任务控制:可以使用jobs命令来查看你暂停了哪些进程。</li><li>后台进程</li><li>文件模式和文件权限<ul><li>权限信息由四个字符组成：<ul><li>r 文件可读</li><li>w 文件可写</li><li>x 文件可执行</li><li><em>-</em> 无</li></ul></li><li>更改文件权限<ul><li>$chmod g+r file </li><li>$chmod o+r file<br>：对于文件file，要为用户组g和其他用户o加上可读权限r。</li><li>如果要取消，则使用go-r。</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="/blog/2017/07/15/Database/1/"/>
      <url>/blog/2017/07/15/Database/1/</url>
      
        <content type="html"><![CDATA[<h1 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h1><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>&emsp;&emsp;表示组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有###操作执行成功，整个事务才提交。事务中的任何一个数据库操作失败，已经执行的任何操作都必须撤销，让数据库返回到初始状态。<br>     <a id="more"></a></p><h2 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h2><p>&emsp;&emsp;事务操作成功后，数据库所处的状态和它的业务规则是一致的，即数据库不会破坏。如从A账户转账100元到B账户，不管操作成功与否，A账户和B账户的存款总额是不变的。</p><h2 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h2><p>&emsp;&emsp;在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对对方产生干扰。准确地说，并非要求做到完全无干扰，数据库规定了多种事务的隔离级别，不同的隔离级别对应不同的干扰程度，隔离级别越高，数据一致性越好，但并发性越弱。</p><h2 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h2><p>&emsp;&emsp;一旦事务提交成功后，事务中所有的数据操作都必须被持久化到数据库中。即使在提交事务后，数据库马上崩溃，在数据库重启时，也必须保证能够通过某种机制恢复数据。</p><h1 id="数据库并发问题"><a href="#数据库并发问题" class="headerlink" title="数据库并发问题"></a>数据库并发问题</h1><p>&emsp;&emsp;一个数据库可能拥有多个访问客户端，这些客户端都可用并发的方式访问数据库。数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。这些问题可用归结为5类。</p><h2 id="脏读-dirty-read"><a href="#脏读-dirty-read" class="headerlink" title="脏读(dirty read)"></a>脏读(dirty read)</h2><p>&emsp;&emsp;A事务读取B事务尚未提交的更改数据，并在这个数据的基础上进行操作。如果恰巧B事务回滚，那么A事务读到的数据根本是不被承认的。来看取款事务和转账事务并发时引发的脏读场景。</p><div class="table-container"><table><thead><tr><th style="text-align:center">时&emsp;间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style="text-align:center">T1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:center">T2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:center">T3</td><td></td><td>查询账户余额为1000元</td></tr><tr><td style="text-align:center">T4</td><td></td><td>取出500元，把余额改为500元</td></tr><tr><td style="text-align:center">T5</td><td>查询账户余额为500元(脏读)</td><td></td></tr><tr><td style="text-align:center">T6</td><td></td><td>撤销事务，余额恢复为1000元</td></tr><tr><td style="text-align:center">T7</td><td>汇入100元，把余额改为600元</td><td></td></tr><tr><td style="text-align:center">T8</td><td>提交事务</td><td></td></tr></tbody></table></div><p>&emsp;&emsp;在这个场景中，B希望取款500元，而后又撤销了动作，而A往相同的账户中转账100元,就因为A事务读取了B事务尚未提交的数据，而造成账户白白丢失了500元。在Oracle数据库中，不会发生脏读。</p><h2 id="不可重复读-unrepeatable-read"><a href="#不可重复读-unrepeatable-read" class="headerlink" title="不可重复读(unrepeatable read)"></a>不可重复读(unrepeatable read)</h2><p>&emsp;&emsp;不可重复读是指A事务读取了B事务已经提交的更改数据。假设A在取款事务的过程中，B往该账户转账100元，A两次读取账户的余额不一致。</p><div class="table-container"><table><thead><tr><th style="text-align:center">时&emsp;间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style="text-align:center">T1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:center">T2</td><td>开始事务</td></tr><tr><td style="text-align:center">T3</td><td></td><td>查询账户余额为1000元</td></tr><tr><td style="text-align:center">T4</td><td>查询账户余额为1000元</td></tr><tr><td style="text-align:center">T5</td><td></td><td>取出100元，把余额改为900元</td></tr><tr><td style="text-align:center">T6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:center">T7</td><td>查询账户余额为900元(和T4读取的不一致)</td><td></td></tr></tbody></table></div><h2 id="幻想读-phantom-read"><a href="#幻想读-phantom-read" class="headerlink" title="幻想读(phantom read)"></a>幻想读(phantom read)</h2><p>&emsp;&emsp;A事务读取B事务提交的新增数据，这时A事务将出现幻象读现象。幻象读一般发生在计算统计数据的事务中。</p><div class="table-container"><table><thead><tr><th style="text-align:center">时&emsp;间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style="text-align:center">T1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:center">T2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:center">T3</td><td>统计总存款数为1000元</td><td></td></tr><tr><td style="text-align:center">T4</td><td></td><td>新增一个事务，存款为100元</td></tr><tr><td style="text-align:center">T5</td><td></td><td>提交事务</td></tr><tr><td style="text-align:center">T6</td><td>再次统计，结果为10100元(幻象读)</td><td></td></tr></tbody></table></div><p>&emsp;&emsp;如果新增的数据刚好满足事务的查询条件，那么这个新数据就进入了事务的视野，因此产生了两次统计结果不一致的情况。<br>&emsp;&emsp;幻想读和不可重复读是两个容易混淆的概念，前者是指读到了其他已经提交事务的新增数据，而后者是指读到了已经提交事务的更改数据(更改或删除)。</p><h2 id="第一类丢失更新-lost-update"><a href="#第一类丢失更新-lost-update" class="headerlink" title="第一类丢失更新(lost update)"></a>第一类丢失更新(lost update)</h2><p>&emsp;&emsp;A事务撤销时，把已经提交的B事务的更新数据覆盖了。这种错误可能造成很严重的问题，通过下面的账户取款转账就可以看出。</p><div class="table-container"><table><thead><tr><th style="text-align:center">时&emsp;间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style="text-align:center">T1</td><td>开始事务</td><td></td></tr><tr><td style="text-align:center">T2</td><td></td><td>开始事务</td></tr><tr><td style="text-align:center">T3</td><td>查询账户余额为1000元</td><td></td></tr><tr><td style="text-align:center">T4</td><td></td><td>查询账户余额为1000元</td></tr><tr><td style="text-align:center">T5</td><td></td><td>汇入100元，把余额该为100元</td></tr><tr><td style="text-align:center">T6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:center">T7</td><td>取出100元，把余额改为900元</td><td></td></tr><tr><td style="text-align:center">T8</td><td>撤销事务</td><td></td></tr><tr><td style="text-align:center">T9</td><td>余额恢复为1000元(丢失更新)</td><td></td></tr></tbody></table></div><p>A事务在撤销时，“不小心”将B事务的转入金额抹除了。</p><h2 id="第二类丢失更新-second-lost-update"><a href="#第二类丢失更新-second-lost-update" class="headerlink" title="第二类丢失更新(second lost update)"></a>第二类丢失更新(second lost update)</h2><p>&emsp;&emsp;A事务覆盖B事务已经提交的数据，造成B事务所做操作丢失。</p><div class="table-container"><table><thead><tr><th style="text-align:center">时&emsp;间</th><th>取款事务A</th><th>转账事务B</th></tr></thead><tbody><tr><td style="text-align:center">T1</td><td></td><td>开始事务</td></tr><tr><td style="text-align:center">T2</td><td>开始事务</td><td></td></tr><tr><td style="text-align:center">T3</td><td></td><td>查询余额为1000元</td></tr><tr><td style="text-align:center">T4</td><td>查询余额为1000元</td><td></td></tr><tr><td style="text-align:center">T5</td><td></td><td>取出100元，把余额改为900元</td></tr><tr><td style="text-align:center">T6</td><td></td><td>提交事务</td></tr><tr><td style="text-align:center">T7</td><td>汇入100元</td><td></td></tr><tr><td style="text-align:center">T8</td><td>提交事务</td><td></td></tr><tr><td style="text-align:center">T9</td><td>把余额改为1100元(丢失更新)</td><td></td></tr></tbody></table></div><p>&emsp;&emsp;在上面的例子中，由于支票转账事务覆盖了取款事务对存款余额所做的更新，导致银行最后损失了100元。相反，如果转账事务先提交，那么用户账户将会损失100元。</p><h1 id="数据库锁机制"><a href="#数据库锁机制" class="headerlink" title="数据库锁机制"></a>数据库锁机制</h1><p>&emsp;&emsp;数据库b并发会引发很多问题，在一些场合下有些问题是允许的，但在另一些场合下可能是致命的。数据库通过锁机制解决并发访问的问题。虽然不同的数据库在实现细节上存在差别，但原理基本上是一致的。</p><ul><li>行共享锁定</li><li>行独占锁定</li><li>表共享锁定</li><li>表共享独占锁定</li><li>表独占锁定</li></ul><h1 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h1><p>​&emsp;&emsp;尽管数据库为用户提供了锁的DML操作方式，但直接使用锁管理是非常麻烦的，因此数据库为用户提供了自动锁的机制。只要用户指定会话的事务隔离级别，数据库就会分析事务中的SQL语句，然后自动为事务操作的数据库资源添加合适的锁。<br>&emsp;&emsp;ANSI/ISO SQL92标准定义了4个等级的事务隔离级别，在相同的数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可能导致不同的结果。</p><ul><li>事务隔离级别分类</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻象读</th><th style="text-align:center">第一类丢失更新</th><th style="text-align:center">第二类丢失更新</th></tr></thead><tbody><tr><td style="text-align:center">READ UNCOMMITED</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">READ COMMITTED</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td></tr><tr><td style="text-align:center">REPEATABLE READ</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center">SERIALIZABLE</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td><td style="text-align:center">不允许</td></tr></tbody></table></div><p>  &emsp;&emsp;SQL 92推荐使用REPEATABLE READ以保证数据的读一致性，不过用户可以根据应用的需要选择适合的隔离等级。</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 事务 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
